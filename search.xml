<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[互联网开发技术 ———— Session2]]></title>
    <url>%2Fliysuzy%2F2018%2F11%2F11%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%20session2%2F</url>
    <content type="text"><![CDATA[Session 2Task 1: System call fork(), exec() and process signallingI. Background Processing123456789101112131415161718192021222324// 该程序模拟了一个shell程序#include &lt;stdio.h&gt;int main( void ) &#123; char *argv[3] = &#123;&quot;Command-line&quot;, &quot;.&quot;, NULL&#125;; int pid = fork(); // 创建子进程的原因：如果在父进程中调用execvp的话，我们做的这个shell程序就只能调用一条命令了。 if ( pid == 0 ) &#123; execvp( &quot;find&quot;, argv ); &#125; wait( 2 ); // wait函数主要做两件事，首先wait暂停调用它的进程直到子进程结束，然后wait通过status取得子进程结束时传给exit的值。wait返回结束进程的PID，如果进程没有子进程或没有得到终止状态值，则返回-1。 //其实在fork之后，父子进程是并行执行的，而我们想要的效果是父进程先等等，等子进程结束之后再继续执行。wait()函数可以做到这一点。 printf( &quot;Finished executing the parent process\n&quot; &quot; - the child won&apos;t get here--you will only see this once\n&quot; ); return 0;&#125;// 这样通过不断地创建子进程，用想要执行的程序代替子进程并且让父进程等待，最后执行完毕，回到父进程，我们也就模拟了一个shell程序。 fork() fork.c() fork（）返回父进程中子进程的进程标识符（pid） fork（）在子节点中返回0 每个进程都可以使用getpid（）查询自己的进程标识符。 exec() exec.c() 运行结果 exec() 系列说明 123456int execl（const char * path，const char * arg，...）;int execlp（const char * file，const char * arg，...）;int execle（const char * path，const char * arg，...，char * const envp []）;int execv（const char * path，char * const argv []）;int execvp（const char * file，char * const argv []）;int execve（const char * file，char * const argv []，char * const envp []）; 每个系统调用都是单词exec，后跟l 或 v，在此之后后可能后跟e或p。 前三个具有execl形式并接受可变数量的参数。要使用此功能，必须加载&lt;stdarg.h&gt;头文件。请参阅示例stdarg.c。 后三者的形式为execv，在这种情况下，参数是使用指向字符串的指针数组传递的，其中最后一个条目为NULL。例如，可能有 char *argv[] = {&quot;Hello &quot;, &quot;world!&quot;, NULL}; 如果名称以l或v结尾，则必须完整地给出程序名称。 如果该名称是由lp或vp结尾，它将搜索使用当前环境变量的文件路径，通常包括/bin/, /usr/bin/，等等。 最后，如果名称由le或ve结尾，则可以包含指示环境变量的字符串数组，每个形式为&quot;ENVVAR=value&quot;且数组为空终止。例如， char *envp[] = {&quot;USER=dwharder&quot;, &quot;HOME=/home/dwharder&quot;, NULL}; II. System call dup and dup2dup() &amp; dup2() dup() 文件描述符在内核中的形态个进程在此存在期间，会有一些文件被打开，从而会返回一些文件描述符，从shell中运行一个进程，默认会有3个文件描述符存在(0、1、2)。0 与进程的标准输入相关联1 与进程的标准输出相关联2 与进程的标准错误输出相关联一个进程当前有哪些打开的文件描述符可以通过/proc/进程ID/fd目录查看。 12#include &lt;unistd.h&gt;int dup(int oldfd); 功能：复制文件描述符 说明： 复制一个和file_desc指向同一个文件的文件描述符, 并且新的文件描述符总是取最小的可用值。（标准输入描述符总是0，并且dup函数调用总是取最小可用的数字，如果关闭0,再调用dup函数，新的文件描述符就是0了。） 返回值：调用成功返回新的文件描述符，调用失败返回-1. e.g. dup() 12345678910111213141516171819202122232425262728#define _POSIX_SOURCE#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#undef _POSIX_SOURCE#include &lt;stdio.h&gt;void print_inode(int fd) &#123; struct stat info; if (fstat(fd, &amp;info) != 0) fprintf(stderr,&quot;fstat() error for fd %d: %s\n&quot;,fd,strerror(errno)); else printf(&quot;The inode of fd %d is %d\n&quot;, fd, (int) info.st_ino);&#125;main() &#123; int fd; if ((fd = dup(0)) &lt; 0) perror(&quot;&amp;dupf error&quot;); else &#123; print_inode(0); print_inode(fd); puts(&quot;The file descriptors are different but&quot;); puts(&quot;they point to the same file.&quot;); close(fd); &#125;&#125; dup() 12#include &lt;unistd.h&gt;int dup2(int fildes, int fildes2); 功能：复制文件描述符，删除旧的文件描述符 功能说明：dup2是一个类似于dup的系统调用，它复制一个文件描述符，使它们成为别名，然后删除旧的文件描述符。这在尝试重定向输出时变得非常有用，因为它自动处理关闭新文件描述符，在一个命令中执行重定向。例如，如果要将标准输出重定向到文件，则只需调用dup2，将文件的打开文件描述符作为第一个命令，将1（标准输出）作为第二个命令。 参数说明： int fildes: 源文件描述符。在调用dup2之后，这仍然是打开的。 int fildes2: 目标文件描述符。此调用返回后，此文件描述符将指向与filedes相同的文件。 返回值：dup2成功后返回第二个参数（fildes2）的值。负返回值表示发生错误。 e.g. dup2() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Scott Kuhl//// This program does not check the return code of close(), dup2(),// execlp(), fork(), and waitpid(). A good program would add those// additional checks!#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define READ_END 0#define WRITE_END 1int main (void)&#123; int fd[2]; pipe(fd); // pipe() could return an error. I&apos;m not checking it. int child1 = fork(); if(child1 == 0) /* we are child 1 */ &#123; // we will be writing to the pipe, no need to read: close(fd[READ_END]); // When we write to stdout for this process, actually write to // the write end of the pipe. I.e., make the stdout file // descriptor be an &quot;alias&quot; for the write end of the pipe. // // To do this, dup2() will actually close stdout and then // create a new file descriptor with the same number as // stdout---and ensure that it behaves exactly the same as the // write end of the pipe. dup2(fd[WRITE_END], STDOUT_FILENO); // I&apos;m not checking return value for error! execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, NULL); // execlp() does not return (except when an error occurred). printf(&quot;execlp() failed.\n&quot;); exit(EXIT_FAILURE); // exit child process if exec fails. &#125; /* Only parent gets here. */ pid_t child2 = fork(); if(child2 == 0) /* we are child 2 */ &#123; // we will be reading from the pipe, no need to write: close(fd[WRITE_END]); // whenever we read from stdin, actually read from the pipe. dup2(fd[READ_END], STDIN_FILENO); // change every &apos;s&apos; into an &apos;X&apos; execlp(&quot;tr&quot;, &quot;tr&quot;,&quot;s&quot;, &quot;X&quot;,NULL); // execlp() does not return (except when an error occurred) printf(&quot;execlp() failed.\n&quot;); exit(EXIT_FAILURE); // exit child process if exec fails. &#125; /* Only parent gets here. If parent doesn&apos;t close the WRITE_END of * the pipe, then child2 might not exit because the parent could * still write data into the pipe that child2 is reading from. */ close(fd[READ_END]); close(fd[WRITE_END]); /* We could call wait() twice here instead of using waitpid() on * child2. * * The &apos;tr&apos; program is written so * that it will read bytes from stdin until there are no more * bytes to read. Since it is actually reading from the pipe, * there are no more bytes to read from the pipe when the write * end of the pipe is closed. The write end will be closed when * child1 exits---because the OS will ensure that stdin, stdout, * stderr, and all other file descriptors are closed when every * program exits. * * Therefore, child2 can only exit when child1 is finished. If * both child1 and child2 ran &quot;ls&quot;, then this assumption wouldn&apos;t * be true because the second &quot;ls&quot; command will exit after * printing to stdout---it doesn&apos;t read any thing from stdin, and * it doesn&apos;t wait for stdin to be be closed by the writer before * exiting. */ int status; waitpid(child2, &amp;status, 0);&#125; 3. Death of Children12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* limit.c */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;int delay;void childHandler ()&#123; int childPid, ChildStatus; childPid = wait (&amp;ChildStatus); printf (&quot;Child %d terminated within %d seconds\n&quot;, childPid, delay); exit(0);&#125;main (argc, argv)int argc;char* argv[];&#123; int pid; signal (SIGCHLD, childHandler); pid = fork (); if (pid ==0) /* child */ &#123; execvp (argv[2], &amp;argv[2]); perror (&quot;limit&quot;); &#125; else &#123; sscanf (argv[1], &quot;%d&quot;, &amp;delay); sleep (delay); printf (&quot;Child %d exceeded limit and is being killed\n&quot;, pid); kill (pid, SIGINT); &#125;&#125;/* Compile and run the program:% cc limit.c -o limit% ./limit 5 ls (See output !)1% ./limit 4 sleep 100 (See output !)*/ 下面内容转自https://www.cnblogs.com/sky-heaven/p/8074273.html (md partial supported) i 什么是僵尸进程？ 首先内核会释放终止进程(调用了exit系统调用)所使用的所有存储区，关闭所有打开的文件等，但内核为每一个终止子进程保存了一定量的信息。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。 而僵尸进程就是指：一个进程执行了exit系统调用退出，而其父进程并没有为它收尸(调用wait或waitpid来获得它的结束状态)的进程。 任何一个子进程(init除外)在exit后并非马上就消失，而是留下一个称外僵尸进程的数据结构，等待父进程处理。这是每个子进程都必需经历的阶段。另外子进程退出的时候会向其父进程发送一个SIGCHLD信号。 ii 僵尸进程的目的？设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。 iii 如何避免僵尸进程？ 通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。 父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。 如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出。 通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。 第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。 iiii 僵尸进程处理办法 wait()函数 1234#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;pid_t wait(int *status); 进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样： pid = wait(NULL); 如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。 wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。返回的是子进程的PID，它通常是结束的子进程状态信息允许父进程判定子进程的退出状态，即从子进程的main函数返回的值或子进程中exit语句的退出码。如果status不是一个空指针，状态信息将被写入它指向的位置可以上述的一些宏判断子进程的退出情况： waitpid()函数略 4. Suspending and resuming processes (暂停和恢复进程) SIGSTOP和SIGCONT信号分别暂停和恢复进程。 Unix shell使用它们来实现内置命令，如stop，fg和bg。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* pulse.c */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;main ()&#123; int pid1; int pid2; pid1 = fork (); if (pid1 == 0) /* the first child */ &#123; while (1) &#123; printf (&quot;pid1 is alive\n&quot;); sleep (1); &#125; &#125;pid2 = fork (); /* second child */if (pid2 ==0) &#123; while (1) &#123; printf (&quot;pid2 is alive\n&quot;); sleep (1); &#125; &#125;sleep (3);kill (pid1, SIGSTOP); /* suspend first child */sleep (3);kill (pid1, SIGCONT); /* resume first child */sleep (3);kill (pid1, SIGINT); /* killl first child */kill (pid2, SIGINT); /* killl second child */&#125;/* To compile and run the program:% cc pulse.c -o pulse% ./pulse(See output!)*/ Task 2: fork(), pipe() and TCP daytime client in C 具体实践]]></content>
      <tags>
        <tag>互联网开发技术</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法制导翻译——S-属性定义的自底向上计算 Python实现]]></title>
    <url>%2Fliysuzy%2F2018%2F11%2F10%2F%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%20%20python%2F</url>
    <content type="text"><![CDATA[一、什么是语法制导翻译 为了提高编译程序的可移植性，一般将编译程序划分为前端和后端。前端通常包括词法分析、语法分析、语义分析、中间代码生成、符号表的建立，以及与机器无关的中间代码优化等，它们的实现一般不依赖于具体的目标机器。后端通常包括与机器有关的代码优化、目标代码的生成、相关的错误处理以及符号表的访问等。语义分析器的主要任务是检查各个语法结构的静态语义，即验证语法正确的程序结构是否真正有意义，也称为静态语义分析或静态检查静态检查比较简单，可以和其他工作结合。将静态检查和中间代码生成结合到语法分析中进行的技术称为语法制导翻译 (syntax-directed translation)。 二、语法制导翻译的基本知识大量文字预警 I. 基本思想 在进行语法分析的同时，完成相应的语义处理。 一旦语法分析器识别出一个语法结构（例如 $ E \rightarrow E+T $ ）就要立即对其进行翻译。 翻译是根据语言的语义进行的，并通过调用事先为该语法结构编写的语义子程序来实现。 对文法中的每个产生式附加一个/多个语义动作(或语义子程序) 在语法分析的过程中，每当需要使用一个产生式进行推导或归约时，语法分析程序除执行相应的语法分析动作外，还要执行相应的语义动作(或调用相应的语义子程序)。 II. 语义子程序的功能 指明相应产生式中各个文法符号的具体含义，并规定了使用该产生式进行分析时所应采取的语义动作。 语义信息是通过文法符号来携带和传递的。 III. 属性 一个文法符号X所携带的语义信息称为X的语义属性，简称为属性 它是根据翻译的需要设置的，主要用于描述语法结构的语义。 文法符号的属性的计算规则称为语义规则。 一个变量的属性有类型、值和存储地址等。 属性值的计算和产生式相关联，随着语法分析的进行，执行属性值的计算，完成语义分析和翻译的任务。 语法结构具有规定的语义，如： $ E \rightarrow E_1 + E_2 $ $ E.val := E_1.val + E_2.val $ IV. 属性值的计算及翻译工作同产生式相关联————语法制导定义法 对应每一个产生式编写一个语义子程序，当一个产生式获得匹配时，就调用相应的语义子程序来实现语义检查与翻译。 适宜在完成归约的时候进行。 V. 语法制导定义 综合属性：节点的属性值是通过分析树中该节点或其子节点的属性值计算出来的 继承属性：节点的属性值是由该节点、该节点的兄弟节点或父节点的属性值计算出来的 固有属性：通过词法分析直接得到的属性 VI. S-属性定义 只含综合属性的语法制导定义称为S-属性定义 通常在自底向上的分析方法计算属性值 可以按照自下而上的顺序来计算分析树中节点的属性 在建立每一个结点处使用语义规则来计算综合属性值，即在用哪个产生式进行归约后，就执行那个产生式的S-属性定义计算属性的值 三、S-属性定义的自底向上计算实现I. 思想 将每个语义规则放到相应产生式的末尾即可得到一个翻译模式（后缀式语法制导翻译模式） 对产生式归约时执行语义动作 II. 条件 在LR分析过程中实现 III. 实现 产生式 语义规则 $ S \rightarrow E $ $ print(E.val) $ $ E \rightarrow E_1 + T $ $ E.val := E_1.val + T.val $ $ E \rightarrow T $ $ E.val := T.val $ $ T \rightarrow T_1 * F $ $ T.val := T_1.val * F.val $ $ T \rightarrow F $ $ T.val := F.val $ $ F \rightarrow (E) $ $ F.val := E.val $ $ F \rightarrow digit $ $ F.val := digit.lexval $ lexval: 固有属性，通过词法分析直接得到的属性。 val: 综合属性，值为该节点或其子节点的属性值计算出来的 需要实现表达式 $ 61 + 7 × 8 + 3 × ( 2 + 1111 ) $ 的值的计算 1. 语义规则存储 需要将语义规则存入文法中，由于在语法分析器中，已经有固定的函数来处理文法了，为了避免修改原有的函数，我将语义规则存入了另一个文件。 语义规则简化为： $ \lbrace S=E, E=E+T, E=T, T=T*F, T=F, F=E, F=g \rbrace $ 2. 读取语义规则，生成输入流与数值流的对应关系 在我实现的语法分析器中，输入流是这种形式的，如果计算 $ 61 + 7 × 8 + 3 × ( 2 + 1111 ) $ ，（字符）输入流 $ g + g × g + g × ( g × g ) $ , $ NUM $ 被映射为符号 $ g $ ,用于对应文法。 由于语法制导翻译是在语义分析中实现的，因此我想可以增加一个输入流，为数值流，与字符输入流相对应。 数值流规则：数字的值为该数字，其余字符的值均为’_’。 3. 创建一个栈————分析栈（值栈） 该栈与符号栈相对应。对应位置即为符号的值。 归约时分析栈同符号栈归约方式相同，只是分析栈需要计算归约出字符的值。 4. 分析栈的归约123456789101112131415161718def calculateRecuctionVal(reductionVals, reductionIndex): # reductionVals: 要归约的所有符号值，reductionIndex: 归约的文法下标 valsDict = &#123;&#125; i = -1 while grammarOriginalListsWithArrow[reductionIndex][i] != '&gt;': if reductionVals[i] != '_': valsDict[grammarOriginalListsWithArrow[reductionIndex][i]] = reductionVals[i] i = i-1 resultVal = 0 if '*' in rule[reductionIndex]: charIndex = rule[reductionIndex].index('*') resultVal = int(valsDict[rule[reductionIndex][charIndex-1]]) * int(valsDict[rule[reductionIndex][charIndex+1]]) elif '+' in rule[reductionIndex]: charIndex = rule[reductionIndex].index('+') resultVal = int(valsDict[rule[reductionIndex][charIndex-1]]) + int(valsDict[rule[reductionIndex][charIndex+1]]) else: resultVal = int(valsDict[rule[reductionIndex][-1]]) print(valsDict) return resultVal 针对该文法，我写了计算该文法归约字符值的函数。 函数思想 创建一个映射，为文法中产生式中的字符与值的映射。比如我们要计算 $ 11+627 $ 使用 $ E \rightarrow E + T $ , 建立映射： $ \lbrace E:11, T:627 \rbrace $ 读取文法对应的语义规则，进行相应计算。 $ E \rightarrow E + T $ 的语义规则是 $ E = E + T $ ，即把 $ E $ 的值与 $ T $ 值相加，赋值给 $ E $ . 返回 $ E $ 的值 四、 源码 https://git.dev.tencent.com/liysuzy/Compilers.git如有问题请与我联系，1121899707@msn.cn]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Python</tag>
        <tag>语法分析</tag>
        <tag>语义分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLR语法分析器 python实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F31%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%20%20python%2F</url>
    <content type="text"><![CDATA[一、语法分析器做什么 语法分析是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。一个语法分析器从词法分析器获得一个词素序列，并验证这个序列是否可以由源语言的文法生成。语法分析器会构造一棵语法分析树，并把它传递给编译器的其他部分进一步处理，在构建语法分析树的过程中，就验证了这个词素序列是否符合源语言的文法。 二、自底向上的语法分析器的实现I. 推导方式输入：文法 $ G=(V,T,P,S) $ 的拓广文法 $ G’ $输出： $ G’ $ 的 $ LR(0) $ 分析表。即 $ action $ 和 $ goto $ 表 步骤： ① 构造 $ I_0 $ 。 $ I_0 = CLOSURE( \lbrace S’ \rightarrow .S \rbrace ) $ ② 通过 $ GO(I_i, X) $ 函数求出 $ LR(0) $ 的项目集规范族 $ C= \lbrace I_0,I_1,…,I_n \rbrace $ ③ 遍历项目及规范族 $ C $ ， $ I_0 $ 对应初始状态 $ 0 $， $ I_i $ 对应状态 $ i $ (1) 若项目 $ A→α·aβ $ 属于 $ I_k $ 且转换函数 $ GO(I_k,a)= I_j $ ，当 $ a $ 为终结符时，则置 $ ACTION[k,a] $ 为 $ S_j $ 。 (2) 若项目 $ A→α· $ 属于 $ I_k $ ，则对任何终结符 $ a $ 和’#’置 $ ACTION[k,a] $ 和 $ ACTION $ [k,#]为 $ r_j $ ， $ j $ 为在文法 $ G′ $ 中某产生式 $ A→α $ 的序号。 (3) 若 $ GO(I_k,A)＝I_j $ ，则置 $ GOTO[k,A] $ 为 $ G_j $ ，其中 $ A $ 为非终结符。 (4) 若项目 $ S′→S· $ 属于 $ I_k $ ，则置 $ ACTION $ [k,#]为 $ acc $ ，表示接受。 II. 关键函数1. CLOSURE(J) 函数 即求J中每一项的闭包。 也可以用递归。12345678function CLOSURE(J): I = J 重复执行： for I 中每个项目，形如A-&gt;α.Bβ，执行： for 增广文法中每一个以B开始的产生式，B-&gt;γ，执行： if 以B开始的加点最左侧的产生式，B-&gt;.γ 不在 I 中，将其加入 I 中 直到 I 不再增大 返回 I 2. GO(I,X) 函数 参数： $ I $ 为项目集闭包。 $ \lbrace X \rbrace $ 为 $ I $ 中点后字符的集合，因此 $ X $ 就是其中一项。比如：$ I_0= \lbrace S\rightarrow .E, E\rightarrow .E+T, E\rightarrow .T, T\rightarrow .T*F, T\rightarrow .F, F\rightarrow .(E), F\rightarrow.g \rbrace $ ，则 $ \lbrace X \rbrace = \lbrace E, T, F, (, g \rbrace $，需要把 $ X $ 中每一项都传入 $ GO $ 函数进行计算。12345function GO(I,X): J = Φ for I 中每一个项目，形如A-&gt;α.Xβ（点后面的字符为 X ），执行： J = J ∪ &#123;A-&gt;αX.β&#125;，即将点右移一位。 返回 CLOSURE(J)，即返回 J 的闭包 3. ★ 如何使用 $ CLOSURE(J) $ $ GO(I,X) $ 以下，大写字母为非终结符，小写字母或符号为终结符 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ ① 构造 $ I_0 $ 。即求增广文法的第一个产生式的闭包 $ CLOSURE( \lbrace S \rightarrow .E \rbrace ) $ 。 即 $ CLOSURE(J), J = {S \rightarrow .E} $ E是非终结符，所以找以E为开始的点在产生式右部的开始的产生式。$ E \rightarrow .T % $ , $ T $ 仍为非终结符，所以再像 $ E $ 一样找 $ T $，把它们都加入 $ J $。 ② 利用 $ GO(I_0, X) $ 构造 $ I_i $ 第①步求出了 $ I_0= \lbrace S\rightarrow .E, E\rightarrow .E+T, E\rightarrow .T, T\rightarrow .T*F, T\rightarrow .F, F\rightarrow .(E), F\rightarrow.g \rbrace $ (1) 首先找出 $ I_0 $ 中所有点后的字符， $ \lbrace X \rbrace = \lbrace E,T,F,(,g \rbrace $ (2) 每一个 $ \lbrace X \rbrace $ 中的字符都会作为 $ GO(I_0,X)中的参数X $ a. 求 $ GO(I_0, E) $ ,得到 $ I_1 $ 此时 $ X $ 为 $ E $ ， 即形如 $ A \rightarrow α.Xβ $ 的产生式为 $ \lbrace S\rightarrow .E,E\rightarrow .E+T \rbrace $ 因此 $ J = Φ ∪ \lbrace S\rightarrow E.,E\rightarrow E.+T \rbrace $ 然后求 $ CLOSURE(J) $ ,返回 $ I_1 $ b. 求 $ GO(I_0, T) $ ，得到 $ I_2 $ , 同上 …….. e. 求 $ GO(I_0, g) $ ，得到 $ I_5 $ , 同上 (3) 再找出 $ I_1 $ 中所有点后的字符， $ \lbrace X \rbrace = \lbrace + \rbrace $ f. 求 $ GO(I_1, +) $ ，得到 $ I_6 $ , 同上…… ③ 所有 $ I_x $ 的集合就是项目及规范族 $ C $ , $ C= \lbrace I_0, I_1, …, I_n \rbrace $ III. 实现0. 数据结构 python 列表、集合等 1. 项目生成步骤： ① 读取文法文件，存入列表 ② 遍历列表的所有元素，为其加点，从产生式的右边的第一个符号的左侧开始加点，点每次右移一位，直到移到最右侧，这些标有点的产生式就是文法的LR(0)项目，即 产生式：S-&gt;AB; 项目：(1) S-&gt;.AB (2) S-&gt;A.B (3) S-&gt;AB. 读取文法后，将终结符、非终结符分别存入终结符列表、非终结符列表，便于之后的判断。 2. 读取规范句型将标识符、符号、关键字等读出，转换为文法可以识别的终结符与非终结符组成的串，等待识别。 3. $ CLOSURE $, $ GO $函数生成$ CLOSURE(J) $12345678910111213141516171819202122232425# 为了与列表CLOSURE区分，我使用了CLOSURE FUNCTION 的简写 CLOSUREFdef CLOSUREF(J): tempClosure = [] for i in J: nodePosition = i.index(&apos;@&apos;) if (nodePosition == (len(i) - 1)) or ((i[nodePosition + 1]) in TERMINATOR): # 点在最后一位 或 点后是终结符 tempClosure.append(i) elif((i[nodePosition + 1]) in NONTERMINATOR): # 点后为非终结符 tempClosure.append(i) searchClosure(i[nodePosition+1], tempClosure) # 传入S-&gt;@B 中的 B，即找以 B 为开始的产生式 if tempClosure in CLOSURE: # 如果当前生成的CLOSURE已经生成过了，则直接返回之前生成的相同的CLOSURE return CLOSURE[CLOSURE.index(tempClosure)] CLOSURE.append(tempClosure) return tempClosuredef searchClosure(c, tempClosure): for i in grammarWithNode: # 遍历所有项目 if i[0] != c: continue if i[1] == &apos;@&apos;: # 点在产生式右部的开始 tempClosure.append(i) if c != i[2] and i[2] in NONTERMINATOR : # 点后的仍然是非终结符，如 E searchClosure(i[2], tempClosure) # 递归找以 E 为产生式开始的，且点在产生式右部的开始 $ GO(I,X) $12345678910111213def GO(I,X): J = [] for i in I: nodeIndex = i.index(&apos;@&apos;) if nodeIndex == len(i) - 1: continue if i[nodeIndex + 1] != X: continue moveRightStr = nodeRightMove(i) # 将点右移一位 J.append(moveRightStr) return CLOSUREF(J) 4. 求FIRST、FOLLOW集FIRST: 寻找最左终结符 递归如：求 $ S \rightarrow Eb $ 求S的FIRST集，E为终结符。 $ S \rightarrow E, E \rightarrow a $ 相当于 $ S \rightarrow a $ , 因此E的最左终结符一定是S的$ E \rightarrow a , E \rightarrow T $ 同理，$ T $的终结符集一定是 $ E $的子集，依次向下递归即可。 FOLLOW: 寻找每个非终结符右侧的终结符，（不考虑空串的情况时）有三种情况: ① $ A \rightarrow aBb $ , $ B $ 为非终结符， $ b $ 为终结符， $ FOLLOW(B) = FOLLOW(B) ∪ \lbrace b \rbrace $ ② $ A \rightarrow aB $ , $ B $ 为非终结符， $ E \rightarrow Af $ 即 $ E \rightarrow aBf $ ， 因此 $ A $ 的 $ FOLLOW $ 集就是B的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FOLLOW(A) $ ③ $ A \rightarrow aBE $ , $ B $ 为非终结符， $ E $ 为非终结符， $ E \rightarrow a $ 即 $ A \rightarrow aBa $ ，因此 $ E $ 的 $ FIRST $ 集就是 $ B $ 的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FIRST(E) $重复这个操作，直到所有 $ FOLLOW $ 集不再增大为止 5. 生成SLR分析表 ① 首先构造 $ I_0 $ , $ I_0 = CLOSURE( \lbrace S \rightarrow E \rbrace ) $，然后根据 “3.”的描述，求出 $ C = \lbrace I_0, I_1, …, I_n \rbrace $ ② $ I_0 $ 为初始状态。构造 $ action $ 表与 $ goto $ 表，$ action $ 表列标所有终结符和’#’, $ goto $表列标为所有终结符，行标均为所有项目及规范族的下标。 ③ 令初始状态 $ k = 0 $, k递增进行如下循环： (1) 如果 $ A \rightarrow α.aβ $ 在 $ I_k $ 中，并且 $ a $为终结符，那么求一下 $ GO(I_k, a) $ 的值是 $ C $中的哪一项，如果求出是 $ I_k $ ， 则 $ action[k,a] = Sj $ ，即在行标为 $ k $, 列标为 $ a $ 的位置上写入 $ Sj $。 (2) 如果 $ A \rightarrow α.Bβ $ 在 $ I_k $ 中，并且 $ B $为非终结符，那么那么求一下 $ GO(I_k, B) $ 的值是 $ C $中的哪一项，如果求出是 $ I_k $ , 则 $ goto[k,B] = Sj $，即在行标为 $ k $, 列标为 $ B $ 的位置上写入 $ j $。 (3) 如果 $ A \rightarrow α. $ , 并且 $ A \rightarrow α $ 在（不加点）文法 $ G $ 中是第 $ j $ 个产生式，那么对于每个终结符（包括#）$ t $ ，如果 $ t ∈ FOLLOW(A) $ ，（A为产生式左部）， 则 $ action[k,t] = rj $ ，即在行标为 $ k $ , 列标为满足要求的 $ t $ 的位置上写入 $ rj $ 。 (4) 如果当前项目为增广文法新加入的项目的中介状态 $ S \rightarrow E. ∈ I_k $ ， 则 $ action $ [k,#] $ = acc $ 。 遍历完 $ C $ 中所有 $ I $ 以及 $ I $ 中所有项目后，$ SLR $ 分析表就生成了。 12345678910111213141516171819202122def generateSLR(): global action, goto action = [[&apos; &apos; for col in range(len(TERMINATOR))] for row in range(len(CLOSURE))] goto = [[&apos; &apos; for col in range(len(NONTERMINATOR))] for row in range(len(CLOSURE))] for k in range(0, len(CLOSURE)): for a in CLOSURE[k]: # Closure内各表达式 nodeIndex = a.index(&apos;@&apos;) if nodeIndex == len(a) - 1: grammarIndex = grammarOriginalLists.index(a[0:len(a)-1]) for ter in TERMINATOR: if a[0] == grammarOriginalLists[0][0]: action[k][TERMINATOR.index(&apos;#&apos;)] = &quot;a0&quot; elif ter in FOLLOW[NONTERMINATOR.index(a[0])]: action[k][TERMINATOR.index(ter)] = &quot;r&quot; + str(grammarIndex) elif a[nodeIndex+1] in TERMINATOR: resultClosure = GO(CLOSURE[k], a[nodeIndex+1]) aIndex = CLOSURE.index(resultClosure) action[k][TERMINATOR.index(a[nodeIndex+1])] = &quot;S&quot; + str(aIndex) elif a[nodeIndex+1] in NONTERMINATOR: resultClosure = GO(CLOSURE[k], a[nodeIndex+1]) aIndex = CLOSURE.index(resultClosure) goto[k][NONTERMINATOR.index(a[nodeIndex+1])] = &quot;G&quot; + str(aIndex) 6. 进行语法分析利用Python的数据结构列表模拟栈的操作，状态栈、符号栈分别存放当前状态、当前的符号，输入流不断进行输入，状态与当前输入利用SLR表进行转换，得到新的状态与符号。 三、 源码 https://git.dev.tencent.com/liysuzy/Compilers.git如有问题请与我联系，1121899707@msn.cn]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Python</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLR语法分析器 C++实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F28%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%20c%2B%2B%2F</url>
    <content type="text"><![CDATA[在文章语法分析器python实现中描述了课本上的算法（利用CLOSURE、GO函数进行SLR分析表的建立）。 一、语法分析器做什么 语法分析是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。 一个语法分析器从词法分析器获得一个词素序列，并验证这个序列是否可以由源语言的文法生成。语法分析器会构造一棵语法分析树，并把它传递给编译器的其他部分进一步处理，在构建语法分析树的过程中，就验证了这个词素序列是否符合源语言的文法。 二、自底向上的语法分析器的实现I. 我的推导方式步骤： 分析输入流，需要使用SLR分析表，[SLR(1),1省略] 得到SLR分析表，需要用DFA生成 得到DFA，需要用NFA生成，NFA-&gt;DFA需要用子集构造法，也就是需要得到Closure 得到NFA，需要得到文法中所有项目 得到项目，需要给文法加点 至此就推导到最开始的文法了 这种做法会有疏漏，但可以应对大部分的文法。 II. 实现&gt; 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ 0. 数据结构 文法：string 数组 项目集：vector&lt;itemStruct&gt; itemStruct为结构体 Closure：vector&lt;closureStruct&gt; item等 1. 项目生成步骤： ① 读取文法文件，将所有文法存入一种数据结构，我选择了string数组 ② 遍历string数组的所有元素，为其加点，从产生式的右边的第一个符号的左侧开始加点，点每次右移一位，直到移到最右侧，这些标有点的产生式就是文法的LR(0)项目，即 产生式：S-&gt;AB; 项目：(1) S-&gt;.AB (2) S-&gt;A.B (3) S-&gt;AB. 读取文法后，将终结符、非终结符分别存入数组，便于之后的判断。 2. 读取规范句型将标识符、符号、关键字等读出，转换为文法可以识别的终结符与非终结符组成的串，等待识别。 3. NFA 生成步骤： ① 遍历每一个项目 S ② 找当前加点位置的下一个字符 C a. 如果 C 是终结符，说明没有空边的情况操作：需要将 S 中的点右移一位得到 S&#39;，再遍历整个项目集寻找与之匹配的项目 A，A 就是 S 的后继，加入NFA图，值为该终结符例如：S-&gt;.aE ====== a ======&gt; S-&gt;a.E b. 如果 C 是非终结符，此时存在空边。譬如，S-&gt;@E, E-&gt;@aB，S 等待 E 的输入，其实就是等待 a 的输入。也就是 S 间接推导到 aB。操作：i. 将 S 加点右移一位得到 S&#39;，若点在项目的最右位置，说明此时需要接收点之前的非终结符，遍历整个项目找到与 S&#39; 匹配的项目下标，加入NFA图，值为该非终结符。例如：S-&gt;@E ====== E ======&gt; S-&gt;E@ , 匹配S-&gt;E@ii. 将 S 加点右移一位得到 S&#39;，若点不在项目的最右位置，需要遍历整个项目集，寻找 以 S 加点右侧第一个非终结符为开始 的项目集合 {E} ，并且 E 的加点一定是在产生式右部的最左侧, 将它们加入NFA图，值为空边（用~表示，与空字符进行区分）例如：S-&gt;@EB ====== ~ ======&gt; E-&gt;@aA, E-&gt;@B 4. $ C $ 生成 $ C $ 代表项目集规范族。 $ C = \lbrace I_0, I_1, I_2, … , I_n \rbrace $ 步骤： ① 读取NFA，每一个点坐标为(m,n)，m , n 代表两个项目，遍历每行构造Closure。 ② 如果 n 对应项目 已经被加入closure, 则不再以 n 作为源进行查找，即查找到第 n行，直接跳过。 ③ 递归 a. 如果NFA途中显示 (m,n) 值为~, 如果该项目还不在 m 构造的Closure中，则递归找该项目的空边，将其也加入Closure中，直到找到一个不含空边的项目为止。 b. 如果NFA途中显示 (m,n) 值不为~，也不为空, 如果该项目还不在 m 构造的Closure中，将其加入。 c. 如果遍历完一行发现为空，说明该状态可能为点在最右侧的状态，即需要归约的状态，需要构造一个Closure只包含该项目。 问题： 使用这种方法构造的Closure并不是真正意义的Closure，可能会出现有多余的Closure的情况， 出现这种情况需要将多余的Closure合并。 5. DFA 生成 数据结构： 1234567891011121314// 项目结构体typedef struct itemStruct&#123; int itemId; // 节点编号 char content[MAX_GRAMMER]; // 节点内容 bool isAdd; //是否添加到closure中 vector&lt;int&gt; closureIds; // 该item属于哪几个Closure&#125;itemStruct;typedef struct closureStruct&#123; int closureId; // 节点编号 vector&lt;int&gt; itemIds;// Closure 下的项目id&#125;closureStruct; 在上一步，我们求出了所有的项目集规范族（其实此时并不是完全规范的，下面会讲为什么），将C中的各项统称为Closure（闭包） 对每一个Closure中的vector&lt;int&gt; itemIds进行遍历，寻找该Closure可以指向谁。如果把每个Closure看作节点，那么这一步就是寻找两个节点的边以及权值。 譬如，当前要找Closure I0 可以与哪个Closure有有向边，因此我们需要遍历当前Closure下的所有item，即读取NFA图，如果该item所在的行有非空的值，说明该item一定可以通过这个非空的值指向下一个item，那么我们只需要知道指向的item在哪一个Closure中即可。（非常拗口，在后面我会举一个例子。） 当我们遍历完所有的Closure后，DFA图就生成了，DFA图中是不存在空边的！ 6. DFA 图的合并及真正的项目及规范族 $ C $ 生成 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ DFA 图（矩阵形式）如图所示 DFA 图的一部分（有向图形式）如图所示 可以看到，在DFA矩阵中，有第一行有两个E，实际上有向图中只有一个E，因为 $ S\rightarrow E., E\rightarrow E.+T $ 本身应该属于一个Closure中。因此需要合并这两个。 算法： ① 遍历整个DFA图，查找哪一行有重复的输入，将其合并。 ② 对于每个合并，要找其对应的两列是否也出现与其相同的情况。（如下图所示） 千万注意下图的情况！如果出现两次合并，Closure仍然是有重复的！因此当我们找到第一行的两个T时，要去找是否第五列、第六列也同时出现T，如果出现，在DFA图中直接将其删掉即可，这样就不会在第10行扫描的时候扫描到两个T。 7. 新的 DFA 生成 将原先的DFA清空。 我们通过DFA 图的合并，得到了真正的项目及规范族C，因此利用这个新的C可以生成完全正确的DFA图，该图就是生成SLR分析表的基础。 8. 求 FIRST、FOLLOW 集FIRST: 寻找最左终结符 递归如：求 $ S \rightarrow Eb $ 求S的FIRST集，E为终结符。 $ S \rightarrow E, E \rightarrow a $ 相当于 $ S \rightarrow a $ , 因此E的最左终结符一定是S的$ E \rightarrow a , E \rightarrow T $ 同理，$ T $的终结符集一定是 $ E $的子集，依次向下递归即可。 FOLLOW: 寻找每个非终结符右侧的终结符，（不考虑空串的情况时）有三种情况: ① $ A \rightarrow aBb $ , $ B $ 为非终结符， $ b $ 为终结符， $ FOLLOW(B) = FOLLOW(B) ∪ \lbrace b \rbrace $ ② $ A \rightarrow aB $ , $ B $ 为非终结符， $ E \rightarrow Af $ 即 $ E \rightarrow aBf $ ， 因此 $ A $ 的 $ FOLLOW $ 集就是B的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FOLLOW(A) $ ③ $ A \rightarrow aBE $ , $ B $ 为非终结符， $ E $ 为非终结符， $ E \rightarrow a $ 即 $ A \rightarrow aBa $ ，因此 $ E $ 的 $ FIRST $ 集就是 $ B $ 的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FIRST(E) $重复这个操作，直到所有 $ FOLLOW $ 集不再增大为止 9. 生成 SLR 分析表 ① 读取DFA图的每个坐标。 ② 判断当前的Closure是否有归约状态（含点在最右侧的产生式），如果有，则需要在该行终结符列下加入rj，j为归约到的文法中的第几项。（需要判断终结符是否在FOLLOW（X）集中，X为归约式的最左部） ③ 如果该坐标的值是非终结符，执行GOTO函数 ④ 如果该坐标的值是终结符，执行ACTION函数 ⑤ 如果出现了既不是终结符也不是非终结符的字符（比如空边），说明DFA图存在错误！SLR表无法生成！ ⑥ 最后，需要找出增广文法加入的产生式的终结状态（即点在最右侧），设其属于item的下标为index，”#”属于的下标为sharpIndex，则ACTION[index][sharpIndex] = “acc” ACTION 函数 ACTION(int closurId, char inTChar) ACTION函数的参数： 第一个：当前坐标的行标，也就是当前坐标所属Closure的下标。 第二个：坐标的值（终结符） ACTION函数的作用： 查找出 当前Closure输入该终结符可以指向的Closure的下标destIndex 在action表中加入一项。 位置：行标为closureId, 列标为当前终结符所属下标，加入的值是”S” + destIndex。 如上图所示，我们需要在action[0, (] 处添加S3，在action[1,g] 处添加S11. GOTO 函数 GOTO(int closurId, char inNTChar) ACTION函数的参数： 第一个：当前坐标的行标，也就是当前坐标所属Closure的下标。 第二个：坐标的值（非终结符） GOTO函数的作用： 查找出 当前Closure输入该非终结符可以指向的Closure的下标destIndex 在action表中加入一项。 位置：行标为closureId, 列标为当前终结符所属下标，加入的值为destIndex。 同上，不再举例。归约状态也如此。 通过这两个函数，SLR分析表就可以生成了。 10. 进行语法分析利用C++栈模拟栈的操作，状态栈、符号栈分别存放当前状态、当前的符号，输入流不断进行输入，状态与当前输入利用SLR表进行转换，得到新的状态与符号。 三、 源码 https://git.dev.tencent.com/liysuzy/Compilers.git如有问题请与我联系，1121899707@msn.cn]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装好虚拟机需要做~]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F24%2F%E8%A3%85%E5%A5%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Virtual Box一、 增强功能1. 增强功能的作用 实现客户机和主机间的鼠标平滑移动 安装虚拟显卡驱动，实现2D和3D视频图形加速，自动调整客户机分辨率 与主机共享剪贴板的内容，也就是说直接可以在主机、客户机之间复制、粘贴（不支持文件） 与主机实现文件共享（共享文件夹） 等等…… 2. 安装增强功能 ① 进入系统 ② 点击菜单“设备”，点击下拉菜单“安装增强功能”。 ③ 弹出对话框，点击运行，会弹出输入密码对话框，输入即可。 ④ 安装程序自动安装，直到出现“Press Return to close this window…”，按回车结束，重启系统即可。 ⑤ 除此之外，需要开启共享剪切板才可以在主机和虚拟机之间复制剪贴板内容。 装完增强功能后，ubuntu关机时千万不要强制关机，要按正常步骤关机，否则增强功能可能会消失 3. 共享文件夹注意：共享文件夹的前提是安装增强功能！ ① 设定共享文件夹。点击菜单“设备”，点击下拉菜单“共享文件夹”，点击右侧菜单“共享文件夹”。 ② 点击右侧加号，选择一个文件夹share，选择后点击自动挂载，固定分配。 ③ 打开命令行，需要输入以下命令 进入/mnt： cd /mnt 创建gongxiang目录： sudo mkdir gongxiang 将“share”目录与“gongxiang”目录进行关联： sudo mount -t vboxsf share /mnt/gongxiang 参数:”share”位置时你windows下的文件夹， “/mnt/gongxiang”位置时你linux下刚创建的哪个文件夹的绝对路径。 ④ 重启系统，现在我们可以在文件资源管理器中看到该文件夹，但是打开会报错 这时候我们需要获取权限，把本机用户加入到vboxsf之中 sudo adduser liysuzy vboxsf ⑤ 再次重启系统，以后就可以在共享文件夹下操作了！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Virtual Box</tag>
        <tag>Ubuntu</tag>
        <tag>增强功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器 C++实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F22%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、 词法分析做什么词法分析是编译器的第一个步骤。 教材定义：词法分析器读入组成源程序的字符流， 并且将它们组织成为有意义的词素(lexeme)的序列。对于每个词素，词法分析器产生如下形式的词法单元(token)作为输出:&lt;token-name, attribute-value&gt; 词法分析器做的任务就是将源程序进行分解为以下五类单词“标识符，关键字，常数，运算符，界符” 二、 词法分析器（简易）实现整个程序流程： 对代码进行预处理，消除注释（单行、多行），目的是让词法分析时不进行过量的超前搜索与回退，以及减少判断注释时的内存消耗。将消除注释的代码存入另一个文件，为词法分析做准备。 读取不含注释的文件，进行单词的识别。每识别一个单词，需要向屏幕输出此法单元&lt;token-name, attribute-value&gt; 注解 将所有关键字、单目运算符、双目运算符、界符分别存放到数组中。 预处理————消除注释 C语言注释：// 单行注释 /* 多行注释 */ “/“出现时有几种情况：“除号”，“单行注释”，“多行注释”，“字符串内的字符常量” 因此需要对这几种情况进行判断。于是采用了编译原理中常用的————自动状态机 当然，这个程序中的状态机并不是严格按照状态机的定义来设计的，仅仅可以进行以上情况的判断。 状态机如下图： 使用状态机的好处: 避免了引号内有注释符号而被识别为注释的情况 可以查找注释不闭合与引号不闭合错误。因为如果读到文件终结时3状态或者5状态，都代表等待下一个/或者“的输入，也就是没有与上一个相匹配的字符。 内存开销小 预处理————文件读取 由于预处理无需进行超前搜索与回退，因此按字符读取是最节省空间与内存的。 词法分析————单词的识别 单词识别优先级： 字母&amp;数字====&gt;状态机外字符（运算符与部分分界符）====&gt;状态机内字符（需要进行状态转换） 但是这样识别会产生一个问题：引号内的字符会被视为标识符，甚至中文是乱码。 于是我考虑优先识别引号。 ① 如果识别到第一个引号，将阻塞后续字符的判断，因为代表这是在一个字符串内，不需要判断是否为标识符、关键字等，直到第二个引号进入，才停止阻塞。可以使用“模二求余”判断引号的单双数。 ② 遇到空格、Tab和回车跳过。 ③ 判断是否是字母或数字或下划线，如果是 是字母或下划线，表示是关键字或标识符，依次进行判断。 是数字开头，判断是否是合法数字。如果合法，是浮点数还是整数，依次进行判断。 ④ 判断是否是运算符 超前搜索一位，依次判断是否是双目运算符、单目运算符、界符。 至此，词法分析基本结束。 三、 词法分析器（简易）代码 https://coding.net/u/liysuzy/p/Compilers/git包含源代码与测试用例，如果测试出现问题，可以联系1121899707@163.com，方便我完善程序。 （很不巧的是，做该项目这天github竟然宕机了！！！只好放在Coding.net了）]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>编译原理</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F14%2FGit%20%E5%9F%BA%E7%A1%80%20%2F</url>
    <content type="text"><![CDATA[一、Git简介 分布式版本控制系统 版本控制系统 本地： 他人无法得知工作集中式：一旦服务器存在问题则丢失分布式：服务器、本地均保存版本服务信息，若中央服务器存在问题，任意一台电脑均可以作为服务器。 二、 Git命令1、 版本库 Remote Repository 远端版本库 Local Repository 本地 Staging 暂存，即将更新成为下一个版本，也有可能不会成为下一个版本 Working Directory 版本库的本地检出，即电脑可以看到的文件 2. git config12git config --global user name &quot;user&quot;git config --global user email &quot;xxx@gmail.com&quot; 提交版本信息。 邮箱：共享工作成果，方便联系 用户名：提交用户 3. git clonegit clone repo [directory] repo: url directory: 可选本地目录， 未指定为与远端相同 已有远端仓库clone到本地 clone 后, .git 目录： 存放相关版本信息 下面以Coding.net为远端版本库为例： 现在有一个已经创建好的版本库：我们来clone一下。 相应目录下Clone了这一个项目。 4. git initgit init repo e.g. git init test 创建一个本地版本库 生成.git目录 直接创建本地git仓库，不需要有远端仓库 5. git status 查看工作区和暂存区的文件状态 那些被创建、修改……的文件 修改了README.md，添加了一个新文件test.txt，并加入内容。此时仅仅存放在工作区，尚未添加到暂存区中。 6. git addgit add [-A] &lt;file&gt; e.g. git add -Ae.g. git add file 添加文件从工作区到暂存区 A: All 暂存工作区成果等待提交 添加test.txt到暂存区，文件变成了带“+”的（因为我装了可视化界面Tortoise），此时已经加入暂存区。 下面使用另一个命令 7. git diffgit diff - 查看工作区改动 git diff --cached - 查看暂存区改动 与 git status 的区别 gti diff 比 git status 更详细, 便于寻找改动，进行检查。 此时查看工作区改动，没有任何显示。因为此时工作区中没有任何文件。 查看暂存区改动，显示较为详细。注意：是—cached，两个“-”号 8. git commitgit commit -m &quot;提交注释&quot; 让暂存区的文件真正变为下一个版本 注释为本次修改的内容梗概 9. git log 查看提交历史 git log 显示提交的用户名、邮箱、日期等，详细显示 git log --oneline 日志大纲，粗略显示 git log --oneline --graph 拓扑图展示 git log --oneline --reverse 逆向显示日志信息，时间正序来排列 10. git reset HEAD 游标： 当前活跃分支的游标 改变本地版本库 git reset --soft commit-id commit-id为错误commit之前的，即HEAD之前的任何一次commit 工作区、暂存区内容均不变，只改变本地版本库 回退到倒数第二次提交，将最后一次提交放入暂存区，即commit的反向操作 git reset --mixed commit-id 工作区不变、暂存区改变，是 git reset 的默认命令。 文件从暂存区删除，回到工作区，只是未被加入暂存区的一个状态。 git reset --hard commit-id 工作区、暂存区均改变 文件从工作区、暂存区删除，丢弃更改。 git reset --soft commit-id ：commit的逆向操作，由已经commit状态变成未commit状态。 git reset --mixed commit-id ：变成未添加状态，即删除了在暂存区中的文件，但是工作区的文件没有更改。 git reset --hard commit-id ：工作区文件也被删除。 11. git rmgit rm &lt;file&gt; 从工作区和暂存区删除文件 git rm -f 强制删除 git rm --cached 从跟踪清单(暂存状态)中删除，文件仍然在目录中，在工作区中是一个未被跟踪的状态。 三、 Git分支1. git branch git 分支 git branch &lt;branch-name&gt; 创建新分支 git branch 列出所有分支 git checkout &lt;branch-name&gt; 切换分支 git checkout -b &lt;branch-name&gt; 创建并切换分支 ++ 命名规则：略++ git clone 工作区 本地版本库 上游版本库 git checkout git fetch https://learngitbranching.js.org/ 图形化工具 12345678910111213141516git branch featuregit branch- *master- featuregit checkout feature- git 分支切换git commit- feature 版本更新，master不变git checkout mastergit checkout -b bugfix- 创建bugfix 分支git commit- bugfix 工作内容更新，master不变 2. git merge 合并分支 分支上的内容需要手动合并到master分支上。 合并变为一次提交 为默认合并方式12345git checkout master 切换到主分支git merge feature 合并feature到master（master更新，加入feature的内容，feature不变）git merge bugfix 合并bugfix到master（master更新，加入bugfix的内容，bugfix不变）git checkout feature 切换到feature git merge master 合并主分支 （将master合并到feature，feature当前在master路径之上，feature与master只差bugfix部分代码，feature会直接移动到master。该操作的原因：使新功能(feature)获得bugfix代码，使feature与master一致，以便于今后基于此进行开发，而不是在没有获得bugfix的feature之上开发。 3. git rebase 合并分支 将当前分支合并到xx分支上 合并仍为多次提交 rebase 合并后仍然可以看到修改的过程 主分支会保留所有分支修改历史12345678git checkout feature 切换到feature分支git rebase master 将feature分支内容合并到master分支 （feature分支：C2 C3，master分支：C6，相当于将C2 C3直接依次放置在C6之下。）git checkout master git rebase feature 将主分支合并到feature上git checkout bugfixgit rebase mastergit checkout mastergit rebase bugfix 4. 冲突 merge conflict 分支的合并会出现修改冲突 出现冲突需要手动解决 同一文件同一位置的不同修改会出现冲突 冲突标识 出现冲突后，分支会处于merging的状态，直到解决冲突并且提交。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEADcontent1===============content2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;some-branch 解决方法：首先确定冲突内容，然后将content1 content2删掉，用合并后content填充，git add xxx. 5. delete branch 新分支的提交已经合并 针对无用的分支可以进行删除 git branch -d &lt;branch-name&gt; git 不是通过复制文件来管理版本库的，即使不删除文件也不会对磁盘空间造成很大影响。 四、Git远端操作1. git fetch 拉取 从远端仓库获取数据，下载本地版本库缺少的提交，储存到本地版本库的远程分支 更新远程分支指针(如：origin/master，本地版本库的分支是与远端版本库的分支相对应的，master——origin/master, bugfix——origin/bugfix) origin/master ≠ master git fetch 不会改变本地仓库状态，不会改变master等分支 git fetch 不会改变工作区和暂存区的内容 需要将master与origin/master进行合并，才可以更新本地版本库的内容。 2. git pull 拉取 + 合并 ① 从远端仓库获取最新数据 ② 更新远程分支指针（如origin/master，origin/bugfix等） ③ 合并本地远端分支到本地分支（origin/master 与 master 合并， origin/bugfix 与 bugfix 合并） 可能出现合并冲突 3. git push 推送 ① 推送本地版本库内容到远端仓库 ② 更新本地仓库远程分支 ③ 更新远端仓库分支 git的数据共享是通过本地仓库的远程分支实现的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴阳师式神语音查询——SSM]]></title>
    <url>%2Fliysuzy%2F2018%2F09%2F11%2F2018-09-11-%E9%98%B4%E9%98%B3%E5%B8%88%E5%BC%8F%E7%A5%9E%E8%AF%AD%E9%9F%B3%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94SSM%2F</url>
    <content type="text"><![CDATA[一、需求我非常喜欢阴阳师这款游戏，因为它精美的画面、建模、音乐，因为有许多重磅声优的加入，因为它玩法独特…… 然而由于式神说的都是日语，大多数时候我们并听不懂他们说的什么。NGA阴阳师论坛有每个式神的语音翻译，但是找起来太麻烦，因此我萌生了一个想法，写一个查询网站来显示每个式神的台词以及翻译，这样不久方便多了吗！ 去大连实训对SSM框架有了一定的了解，因此我仍然使用SSM框架。 二、数据库设计阴阳师台词可以分为几类：点击、出场、受击、死亡、技能1、技能2、技能3几类。而每个类别下又可能有多条语音。我先列出了必需的字段： 式神名称 式神稀有度 声优 语音类型 日语语音 中文语音 面灵气 SSR 花泽香菜 点击1 XXXX XXXX 为了使数据库满足第三范式，我又对其进行了拆分与细化。 式神表 字段：式神ID、式神名称中文、式神名称英文、式神稀有度【外键】、式神CV【外键】 稀有度表 字段：稀有度ID、稀有度 CV表 字段：CV ID、CV姓名、CV国籍 语音表 字段：语音ID、式神ID【外键】、日文语音、中文语音、罗马语音、语音类型【外键】、语音音频地址 语音类型表 字段：语音类型ID、语音类型、觉醒前后 三、网页设计原本想使用`bootstrap`做这个网站，但是`bootstrap`太过于传统商务。因此我使用了基于`bootstrap`的CSS框架`Flat-UI` （实际上只是用了这个CSS框架的响应式布局与按钮组件，2333333） 核心功能是显示语音台词，因此要醒目。于是我采取了如下图的一种设计。]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转木马]]></title>
    <url>%2Fliysuzy%2F2018%2F08%2F24%2F%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[追いかけて今日も歩き続ける 『僕にできること』 初这是我的第一首原创歌曲《旋转木马》φ(゜▽゜*)♪ 故事灵感来源： 同学放假回家，自己暂时呆在学校的失落。 灵感迸发： 欣赏了国家大剧院的《2011年无忧宫长笛音乐会》。 主旋： 采用和声小调式。 乐器选择： 主旋使用长笛，“笛”在中国古代多代表一种悲凉凄切的情感（西方长笛与中国“笛”不同，但音色仍然可以表达凄凉的情感）。长笛在交响乐队中常担任主要旋律，因此我选择长笛作为主旋乐器。_[Native Instruments Kontakt Factory Library / Flute]_ 主歌的后部分与副歌使用长笛作为伴奏部分，但是演奏的仍然是主旋的变奏。 主歌的后部分与副歌使用弦乐作为旋律的演奏乐器，钢琴作为伴奏。弦乐使用的是以大提琴为主的音色，更浑厚、凄切，钢琴则演奏琶音与和声，二者相辅相成。 旋律设定： 开场即是主旋，而且一连演奏三遍，有人对我说是不是太多余，我认为是刚刚好吧，因此没有删掉一部分。三遍是循序渐进加入乐器，而且每一遍乐器的演奏风格是不同的，就使这种重复感降低。 副歌部分是主旋和弦的变奏，钢琴演奏的是主旋的变奏，而弦乐演奏的是主旋的底音，当然也有所变化。副歌结束后是一段钢琴的solo，渐强渐快。进入变奏。 变奏转换情感，激昂欢快，速度提升至170-180，其实这一段就是一段圆舞曲，可以想象…… 故事描述：说了这些其实一听就可以感觉出来，其实上面的这些都是与故事相对应的……描绘几个场景 =￣ω￣= 王子与公主濒死 王子与公主展开回忆 王子幼时即被王后迫害 一位小女孩的到来让王子有了开心的生活 恶毒的王后要拆散王子与小女孩 王子与小女孩与王后斗智斗勇 悲剧 听起来似乎很幼稚，但是是一种理解。 本意是什么呢？(+_+)? 还是埋藏心底吧！ 分享：《SKY’s the limit》 楽しことばっかりの 人生なんかじゃないけど じゃあせめて今だけ 彩って夢見せて ----《SKY's the limit》 虽然生活并非都事事顺心令人愉悦，但是那也至少在此刻，染上希望实现梦想 。 Being alive, being vivid.]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站第一天！纪念一下]]></title>
    <url>%2Fliysuzy%2F2018%2F08%2F23%2Ffirst-day%2F</url>
    <content type="text"><![CDATA[不说啥了，开始工作！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
