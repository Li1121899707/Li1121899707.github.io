<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[����������ص�֪ʶ]]></title>
    <url>%2Fliysuzy%2F2019%2F11%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[��һ�� �����������ϵ�ṹ ���Դ�� a:���������ĸ����ɡ���������� b:�������������ָ�꣨���ʡ�����ʱ�ӡ�ʱ�Ӵ�������������� c:��������繦�ֲܷ�ṹ d:���������Э�顢�ӿڡ�����ȸ��� e:ISO/OSI�ο�ģ�ͺ�TCP/IPģ�� �������� ���� ISP(Internet? Service? Provider)�������������ṩ�� ������һ���ɶ�����齻�����Ͷ��ͨ����·��ɡ���ϵͳ��������ͨ��ISP������������ Protocol��Э�� ������������Ϣ���պͷ��͵�һ����� ������Э�飺TCP/IPЭ�� TCP��Transmission Control Protocol�����������Э�� IP��Internet Protocol��������Э�� RFC��Request For Comments����IETF�ƶ��ı�׼�ĵ�������������׼����IETF��Internet Engineering Task Force���ƶ��� Intranet��ר�õ��ڲ����� ����������·��������·��Э�������������ͬ�� ר���ڵ���������������ר���ⲿ������������Ϣ(�ɷ���ǽ����)�� ���绮�� �����Ե ��Χ���������� ����Ӧ�� ������� ·���� ͨ����· ��ϵͳ���������������ļ���� �ڡ������Ե�� ����Ӧ�ó�����Web�������ʼ���������Ϸ�� �ͻ�����Client�����û���������ƶ�PC��PDA�ȵ� ��������Server�����ṩ���񣬹��ܸ�ǿ�Ļ�������Web���������ʼ������� ������������� �����·����׼ ��ɲ��֣�Ӳ���������Э�� ������ʽ����Ե���֡����Ĳ��� ������ɣ�ͨ����������Դ���� ���������Ĺ��� ����ͨ�� ��Դ���� �ֲ�ʽ���� ��߿ɿ��� ���ؾ��� ���������ķ��� ð�ź�Ϊ�ؼ��� ���ֲ���Χ�� ��������WAN���������룻�����������Ĳ�����������·���������� ������ (MAN) ����̫�� ������ (LAN) ���㲥���� ���������� (PAN) �����似���� �㲥ʽ���磺�������ŵ������������������е����ߡ�����ͨ�����硣 ��Ե����磺���÷���洢ת��·��ѡ�񣻹������� �����˽ṹ�� �������� ���������� �������磺���ƻ������� ��״������ ��ʹ���߷��� ������ ר���� ������������ ��·�������� ר����·���׶Σ����ӡ����䡢�Ͽ����绰���硣 ����ֱ�Ӵ��ͣ�ʱ��С������·�����ʵ͡����ܳ��������·������������в����ơ� ���Ľ������� �Ӹ�����Ϣ�������������洢-ת������ ����һ�Զࡢ���һ���ʡ����Բ����ƣ�������������Դ�����������˻���ʱ�ӡ� ���齻������ �̶����ȵ����ݿ�Ĵ洢-ת������ �������ڹ���ʱ��С��ƽ�����������٣����ڱ�׼�����ձ������ ��������ʷ��� ���� ���� ����ָ�꣨������ܣ� �ֲ�ṹ �� �ӵ͵��ߣ���һ�㣬�ڶ���… ��ͬ������ͬһ��Ϊ�ԵȲ�/�Ե�ʵ�� n ��ʵ�ֵķ���Ϊ n+1 ������ PDU ��Ϊ�����֣�**���ݲ���(SDU)**�� ������Ϣ����(PCI) �������ݵ�Ԫ��SDU����Ϊ����û���Ҫ��Ĺ��ܶ�Ӧ�ô��͵����ݡ� Э�������Ϣ��PCI��������Э���������Ϣ�� Э�����ݵ�Ԫ��PDU�����ԵȲ��֮�䴫�͵����ݵ�λ��Ϊ�ò��PDU�� �� n ��дΪ��n-SDU/n-PCI/n-PDU PDU��ͨ�������� �����PDU������ ��·��PDU��֡ �����PDU������ �����PDU������ Э�� �������е����л������Э����Լ�� �������������벻��Э�顣 ������ͨ��ʵ��֮�䷢�͡����ձ��ĵ���ʽ ������˳�� ���Լ��յ���������ȡ�Ķ����� ���Ե�ʵ������ͨ�ŵĹ��򼯺ϣ���ˮƽ�ġ� Э��Ĺ��ɣ� �﷨���������ݵĸ�ʽ ���壺��Ҫ��ɵĹ��� ͬ����ʱ��ʵ��˳�� Ӧ�ò� �ṩ��������Ӧ�á�����Ӧ������ HTTPЭ�飬FTPЭ�飬SMTPЭ�飬DNSЭ��� ����� ��Ӧ�ó���Ŀͻ����ͷ�����֮���ṩ����Ӧ�ò㱨�ķ��񡣴������Ķ����������̼� TCPЭ�飬UDPЭ�� ����� ����������֮�䴫���������飨���ݱ������������� IPЭ�飬ICMPЭ�飬ѡ·Э�� ������·�� ���ڽ���Ԫ֮�䴫�����ݣ�֡ �� PPP����̫��Э�� ����� �ڽڵ�֮�䴫������� EIA-232C��EIA/TIA RS-449��CCITT��X.21 Э��ֲ��ŵ�: ����������˽�Э��Ĺ淶ϸ�� �ṹ��������֮�����������ʵ�ֺ�ά�� ģ�黯��������϶ȣ����ڸ���ϵͳ��� �ӿ� ͬһ�����������֮�佻����Ϣ�����ӵ� ͬһ�����������֮���ʵ��ͨ��������ʵ㣨SAP�����н��� �� n ���SAP ���ǵ� n+1 ����Է��ʵ� n �����ĵط� ���� �²�Ϊ���ڵ��ϲ��ṩ���ܵ��á�����ֱ�� Э����ˮƽ�� ������һЩ�����ΪOSIԭ� ���󣺷����û� $ \rightarrow $ �����ṩ�� ָʾ���ṩ�� $ \rightarrow $ �û� ��Ӧ���û� $ \rightarrow $ �ṩ�� ֤ʵ���ṩ�� $ \rightarrow $ �û� ������ࣺ��������/�����ӣ��ɿ�/���ɿ�����Ӧ��/��Ӧ�� �������ӵķ��� �ɿ������ݴ��ͣ��޲������ �������� ӵ������ �����ӷ��� ���ɿ� ���������ơ�ӵ������ OSI �ο�ģ�� �� ���䵥λ ���� ���� Ӧ�ò� �û�������Ľ��� ��ʾ�� ��������ͨ��ϵͳ�н�����Ϣ�ķ�ʽ �ٲ��ó���ı�׼�����������ݽṹ�����Ҳ��ñ�׼�ı�����ʽ��������ѹ�������ܽ��� �Ự�� ��ͬ�������������֮����лỰ ����ͬ����SYN������������ֹ��������̼�ĻỰ ����� ���ĶΣ�TCP���û����ݱ���UDP�� ��������������֮���ͨ�� Ϊ�˵��������ṩ�ɿ��Ĵ���������������ƣ����������������������ݴ���ȷ��� ����� ���ݱ� ͨ�����������п��� ��������Э�����ݵ�Ԫ�����飩��Դ�˴���Ŀ�Ķˣ�Ϊ���齻�����ϵĲ�ͬ�����ṩͨ�ŷ���·��ѡ���������ơ������ơ�ӵ������ ������·�� ֡ ������㴫����IP���ݰ���װ��֡ �������ơ���������������� ����� ���� ������ý����Ϊ���ݶ��豸͸���ش���ԭʼ������ TCP/IPģ�� �� Э�� Ӧ�ò� HTTP, SMTP, DNS, FTP ����� TCP, UDP ���ʲ� IP ����ӿڲ� �� OSI TCP/IP ����� ֧�������ӡ��������ӵ�ͨ�� ֧�������ӡ��������ӵ�ͨ�� ����� ��֧���������� ��֧�������� �ڶ��� ����� ���Դ�� a:ͨ�Ż�������ŵ����źš�������Ԫ�����ء����ʡ���Դ�����޵ȣ� b:�ŵ��������ο�˹�ع�ʽ����ũ��ʽ�� c:��·���������Ľ�������齻�� d:���ݱ������· e:������ʡ������ӿ����� f:������豸���м������������� ������ ������·�� ���Դ�� a:������·��Ĺ��� b:�����ƣ������롢������룩 c:�������ơ��ɿ������뻬�����ڻ��� d:ֹͣ���ȴ�Э�顢����N֡Э�飨GBN����ѡ���ش�Э�飨SR�� e:���ʷ��ʿ��ƣ�MAC��Э�飨�ŵ����֡�������ʡ���ѯ���ʣ� f:����������̫����IEEE802.11���������������VLAN�� g:�������Ļ������PPPЭ�� h:���š��������������ĸ�������ԭ�� ������ ����� ���Դ�� a:�����Ĺ��� b:·���㷨����������·���㷨����·״̬·���㷨�����·�ɣ� c:IPv4���顢IPv4��ַ��NAT���������֡��������롢CIDR��·�ɾۺ� d:ARPЭ�顢DHCPЭ����ICMPЭ�� e:IPv6����Ҫ�ص㡢IPv6��ַ f:·��Э�飨RIP��OSPF��BGP�� g:·����������빦�ܡ�·�ɱ���·��ת�� ������ ����� ���Դ�� a:�����Ĺ��� b:�����Ѱַ��˿ںš������ӷ������������ӷ��� c:UDP���ݱ���UDPУ�� d:TCP�Ρ�TCP���ӹ���TCP�ɿ����䡢TCP����������ӵ������ ������ Ӧ�ò� ���Դ�� a:�ͻ�/������Ӧ��ģ����P2PӦ��ģ�� b:DNSϵͳ����������ռ䡢�����������������������̣� c:FTP��FTPЭ��Ĺ���ԭ�������������������ӣ� d:�����ʼ�ϵͳ����ɽṹ���ʼ���ʽ��MIME��SMTP��POP3�� e:WWW��WWW�ĸ�������ɽṹ��HTTPЭ�飩 f:P2P�ļ��ַ�Ӧ�õĻ���ԭ��]]></content>
      <categories>
        <category>���������</category>
      </categories>
      <tags>
        <tag>���������</tag>
        <tag>����</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络重点知识]]></title>
    <url>%2Fliysuzy%2F2019%2F11%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[重点知识 各种名词（按顺序） 第一章 ISP(Internet Service Provider)：因特网服务提供商 网络由一个由多个分组交换机和多段通信链路组成。端系统（主机）通过ISP介入因特网。 Protocol：协议 控制网络中信息接收和发送的一组软件 因特网协议：TCP/IP协议 TCP（Transmission Control Protocol）：传输控制协议 IP（Internet Protocol）：网际协议 RFC（Request For Comments）：IETF制定的标准文档。是因特网标准，由IETF（Internet Engineering Task Force）制定。 Intranet：专用的内部网络 所用主机、路由器、链路和协议等与因特网相同。 专网内的主机不能随意与专网外部的主机交换信息(由防火墙控制)。 网络划分 网络边缘 外围部件、主机 网络应用 网络核心 路由器 通信链路 端系统：与因特网相连的计算机 在“网络边缘“ 运行应用程序，如Web、电子邮件、网络游戏等 客户机（Client）：用户，桌面和移动PC和PDA等等 服务器（Server）：提供服务，功能更强的机器，如Web服务器和邮件服务器 C/S（Client/Server Model）：客户机/服务器模式 客户机程序(Client program)：服务请求方。发出请求，并从服务器程序接收服务。 服务器程序(Server program)：服务提供方。接收客户机请求，并提供服务。 P2P（Peer to peer）：对等模式 面向连接的服务 可靠的数据传送（无差错、按序） 流量控制 拥塞控制 无连接服务 不可靠 无流量控制、拥塞控制 网络核心 包括分组交换、电路交换等 网络分类 根据作用范围分 LAN（Local area network）：局域网 WAN（Wide area network）：广域网 MAN（Metropolitan area network）：城域网 根据网络拓扑结构分 星型、环形、总线、树形、分布式 根据适用范围分 公用网，专用网 接入网 分组交换中的时延、丢包和吞吐量 协议 因特网中的所有活动，都受协议制约。 因特网的运行离不开协议。 定义了通信实体之间发送、接收报文的格式 和传输顺序 ，以及收到报文所采取的动作。 应用层 提供各种网络应用。传输应用报文 HTTP协议，FTP协议，SMTP协议，DNS协议等 运输层 在应用程序的客户机和服务器之间提供传输应用层报文服务。传输报文段。——进程间 TCP协议，UDP协议 网络层 主机和主机之间传输网络层分组（数据报）——主机间 IP协议，ICMP协议，选路协议 数据链路层 在邻近单元之间传输数据（帧 ） PPP，以太网协议 物理层 在节点之间传输比特流 协议分层优点: 概念化，便于了解协议的规范细节 结构化，各层之间独立，易于实现和维护 模块化，减少耦合度，便于更新系统组件 网络核心 数据通过网络传输的方式以及对比： 传输方式 电路交换 报文交换 分组交换 对比 电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。 报文交换：整个报文先传送到相邻结点，全部存储下来后，再转发到下一个结点。 分组交换：单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后，再转发到下一个结点。 电路交换与分组交换两者比较 效率：电路交换低 利用率：分组交换高 分组交换可以共享带宽 电路交换适合实时服务 分组交换成本更低 电路交换 特点 采用多路复用技术（FDM或TDM） 预留端到端资源（缓存，链路带宽） 发送方以恒定速率向接收方发送数据 工作机制 拨号⟶\longrightarrow⟶ 接通⟶\longrightarrow⟶ 通信⟶\longrightarrow⟶ 挂机 每个链路可有n条电路，能够支持n条同步连接，两台主机建立端到端专用连接，该连接获得链路带宽的1/n 缺陷 效率低，无数据传输时造成网络资源浪费 创建端到端电路以及预留端到端资源过程复杂 报文交换 将要发送的整个信息作为一个报文发送 采用存储转发技术： 整个报文先传送到相邻结点，全部存储下来，再转发到下一个结点。 分组交换 特点 不需预留资源 按需使用资源，可能排队等待，发送的时候可能有其他分组发送 分组以链路的最大传输速率传输 传输过程采用存储转发传输机制（分组交换机先将输入端的整个分组接收下来（存储），再从输出链路转发传输出去） 工作机制 源端将报文划分为小的数据块（packet） 每个分组通过一系列链路和分组交换及传送，直到目的端 目的端恢复原报文 相关参数 存储转发时延： 将一个分组转发到输出链路上所需时间。若一个分组长L bit，链路速率R，该时延是L/R s。 输出缓存 （输出队列）： 用于保存准备发往某个链路的分组。每条相连的链路都对应有一个。 排队时延：分组在输出缓存中等待转发的时间。 某条链路上要转发的分组多，需在其输出缓存中等待。排队时延是变化的，与网络中的拥塞有关。 分组丢失： 当缓存空间已满时，有分组要被丢弃。 分类 虚电路网络 数据报网络 多路复用技术 在一条传输链路上同时建立多条连接，分别传输数据 FDM（Frequency-division Multiplexing）：频分多路复用 按频率划分若干频段 TDM（Time-division Multiplexing）：时分多路复用 时间划分为固定的帧，每帧划分为固定数量的时隙，每个时隙专用于一个连接。 分组交换中的时延、丢包 四种时延 节点处理时延 检查比特差错 决定输出链路 微秒级或更低 排队时延 分组等待在链路上传输的排队时间 知识：流量强度，分组丢失 毫秒到微秒级 传输时延 将分组的所有比特 推（传）向链路所需要的时间 传输时延 = L / R ​ R = 链路的传输速率（bps） ​ L = 分组长度（bit） 毫秒级到微秒级 传播时延 一个比特从链路的起点到下一节点（路由器）传播所需要的时间 传播时延 = d / s ​ d = 两个节点之间距离 ​ s = 信号在线路上单位时间内传送的距离（2×10^8m/s ～ 3×10^8m/s ） 毫秒级 总时延 = 四时延相加 端到端时延 信号从一个节点到另一个节点所花费的传播时间。 例子——Traceroute，用来追踪源和目的之间经过的路由 ： 连接知识：ICMP协议【网络层，4.4.3-因特网控制报文协议】 过程： ① 源主机中Traceroute程序向目的主机发送一系列普通的IP数据报，数据报中**携带不可达的UDP端口号的UDP报文段。**第iii个报文段的TTLTTLTTL设置为iii。以三个相同TTLTTLTTL为一组发送。 ② 当第nnn个报文段到达第nnn台路由器时，TTLTTLTTL正好减为0。根据IPIPIP协议规则，路由器会丢弃该数据报，并向源主机发送一个ICMP警告报文（Type:11,Code:0Type: 11, Code: 0Type:11,Code:0）。 ​ 当该报文返回源主机时，源主机根据定时器得出往返时延，从ICMP报文中得到第nnn台路由器的名字与IP地址。 ③ 当该报文到达目的主机时，该目的主机向源发送一个端口不可达的ICMP警告报文（Type:3,Code:3Type: 3, Code: 3Type:3,Code:3），源主机以此判断探测结束。 带宽总是小于实际物理带宽 1）网络协议限制了物理带宽的使用（如CSMA/CD、TCP可靠数据传输） 2）信道利用率低 3）时延：传输时延、传播时延、处理时延、排队时延 4）流量控制：发送方速率应匹配接收方应用进程的接收速率 5）拥塞控制：数据报长度应小于拥塞窗口，也应小于流量窗口,当出现拥塞时，发送方应减小发送速率。 WEB&amp;HTTP 交互过程 客户（浏览器）（从其套接字接口）向服务器发送HTTP请求报文 服务器（从其套接字接口）向用户回发HTTP相应报文 HTTP协议底层运输协议是TCP协议 创建TCP连接⟶\longrightarrow⟶交换报文⟶\longrightarrow⟶关闭TCP连接 TCP可以为HTTP提供可靠的数据传输服务：客户机进程和服务器进程发出的每个HTTP报文能完整地到达对方 HTTP是无状态协议 无状态协议：不保存用户的任何信息 使用无状态协议的原因：有状态协议维护复杂，而且一旦客户与服务器失效，会出现状态不一致问题 WEB使用C/S结构 WEB Server总是打开，有一个固定的IP地址，为多个浏览器服务 HTTP连接 HTTP默认使用持续连接 使用持续连接原因 非持续连接有诸多缺点 服务器负担重，每一个请求对象建立和维护一个新的连接 每一个对象的传输时间延长，包含两个RTT时延，一个用于TCP建立，一个用于请求与接受对象 非持续连接 每个TCP连接只传送一个WEB对象 只传送一个请求/相应 工作过程： ① 用户初始化TCP连接，发送一个TCP连接请求报文 ② 服务器在80端口监听TCP连接请求，回送一个TCP确认响应报文 ③ 客户发送HTTP请求报文到TCP连接套接字，报文指明客户需要的WEB对象之一，报文包含HTTP请求与TCP确认 ④ 服务器接收请求报文，产生响应报文，发送到其TCP连接套接字 ⑤ HTTP服务器关闭TCP连接 ⑥ HTTP接收包含HTML文件的响应报文，显示并解析HTML文件 重复上述过程。 每个TCP连接在服务器返回对象后关闭 每个TCP连接只传输一个请求报文和一个响应报文 浏览器可以同时打开多个连接 RTT计算： 2RTT + 文件传输时间 2RTT：1RTT（发起TCP连接）+ 1RTT（请求文件） 持续性连接 一个TCP连接上可以传送多个WEB对象 传送多个请求/相应对 连接经一定时间间隔(超时间隔)未被使用，服务器就关闭该连接 非流水线方式：客户机接收到前一个相应之后才能发送新的请求 缺点：服务器发送完对象等待请求时会出现空闲状态 流水线方式：客户可以一个接一个发送请求，服务器可以一个接一个连续发送相应对象 优点：节省RTT时延，TCP连接空闲时间很短。 Cookie 四部分 在HTTP响应报文中有一个cookie首部行（由服务器产生） 在HTTP请求报文中有一个cookie首部行（请求时使用Cookie ID进行特定访问） 用户主机中保留有一个 cookie 文件并由浏览器管理 Web站点的后端数据库保存cookie WEB 缓存（代理服务器） 客户机⟷\longleftrightarrow⟷WEB缓存器⟷\longleftrightarrow⟷起始服务器 工作过程 浏览器：建立一个到缓存的TCP连接，并向缓存发送一个对该对象HTTP请求 WEB缓存器：检查本地是否有该对象的拷贝 有：用HTTP响应报文向浏览器转发该对象 无：与该对象的起始服务器打开一个TCP连接 优点：减少客户机请求的响应时间，减少机构内部网络与因特网连接链路上的通信量。 保持代理服务器中的内容为最新版本：条件GET方法 304 Not Modified SMTP 是应用层协议 使用TCP可靠数据传输服务 DNS 提供服务 进行主机名到IP地址的转换 主机别名 邮件服务器别名 负载分配 运输层环境：DNS协议运行在UDP之上，使用53号端口 特点：DNS通常直接由其他的应用层协议 （包括HTTP、SMTP 和FTP）使用，以将用户提供的主机名解析为IP地址。用户只是间接使用 。 集中式设计的问题： 单点故障 流量巨大 集中式数据库会造成低速、拥塞 维护艰难 工作过程（例） 请描述通过手动查询本地DNS对www.weihai2018.com解析的过程，并详细描述如何获取层次结构的组成及其各层次功能。 DNS服务器类别 域名 IP 顶级域名服务器 d.gtld-servers.net 192.31.80.30 根名称服务器 c.root-servers.net 192.33.4.12 权威名称服务器 Ns1.weihai.2018.com 61.135.165.235 本地名称服务器 ns.sdjnptt.net.cn 202.102.128.68 www.weihai2018.com 61.135.169.125 ① 本地主机首先向本地DNS服务器请求解析www.weihai2018.com 的IP地址，如果本地DNS服务器缓存中由此条记录，会直接返回。如果本地DNS没有记录，本地DNS服务器还要向根名称服务器查询，请求能解析.com域名的顶级域名服务器。 nslookup -qt=ns com 192.33.4.12 ② 本地DNS得到顶级域名称服务器IP地址后，向顶级域发送请求，获取能解析weihai2018.com 的权威名称服务器。 nslookup -qt=ns weihai2018.com 192.31.80.30 ③ 本地DNS得到权威名称服务器IP后，向权威名称服务器发送请求，获取www.weihai2018.com 的IP地址，本地DNS存储后将在之后返回到本地主机。 nslookup -qt=a www.weihai2018.com 61.135.165.235 UDP 使用UDP协议原因 无连接创建 简单，无需维护连接状态 段首部小（8字节） 无拥塞控制 UDP差错检测 UDP检查和字段 无连接的复用和分解 接受主机分解：将接收的段交付给正确的套接字 在发送主机复用：从多个套接字收集数据用首部封装数据 UDP套接字：（目的地址IP地址，目的地址端口号） 可靠数据传输 rdt1.0——完全可靠信道传输 发送端接收端独立 rdt2.0——含有比特差错信道的可靠数据传输 停-等协议 特性 接收方的反馈：肯定应答（ACK）/否定应答（NAK） 差错检测：检验和字段 重传 缺陷 ACK/NAK出错 rdt2.1——发送方处理受损的ACK/NAK rdt2.2——删除了NAK rdt3.0——具有比特差错的丢包信道的可靠数据传输 流水线协议 增加序列号 发送方/接收方设置缓冲 形式 回退N步（GBN） 累积确认 超时重传所有发送但是没有确认的分组 乱序到达的分组直接丢弃 选择性重传（SR） 加入缓冲 每收到ACK，窗口向右滑动 TCP 1. 序列号与确认号 2. TCP可靠数据传输 要求：无损坏，无间隔，非冗余，按序 特点 流水线发送 累积确认 单个重传计时器 重传 超时 重复ACK 发送方和接收接收方特点 发送方：单一定时器，多个发送窗口 接收方：多个接收窗口，累积应答 受到错误数据包如何处理 对最近一次已经确认过的分组再次确认 收到乱序数据报应该如何处理 根据上层应用的设置，一般是缓存，当收到完整的数据包时向上递交 快速重传：在定时器超时之前即进行重传 3. TCP连接管理 三次握手 ① C ⟶\longrightarrow⟶ S ：SYN报文段，指定初始序号Seq，没有数据 ② C⟵\longleftarrow⟵ S ：SYN ACK报文段回复，服务器为该连接分配缓冲区和变量，指定服务器初始序号 ③ C⟶\longrightarrow⟶ S：SYN ACK报文段 连接的关闭 ① C⟶\longrightarrow⟶ S：FIN控制报文段 ② C ⟵\longleftarrow⟵ S：ACK回答，关闭连接，发送FIN，等待客户端确认 ③ C⟶\longrightarrow⟶ S：进入超时等待，将对接的FIN进行确认，发送ACK确认关闭 ④ S收到ACK关闭连接 4. TCP流量控制 发送方不能发送太多、太快的数据让接收方的缓冲区溢出 接收窗口（Receive window / rwnd / RevWindow） 服务 匹配速度服务: 发送速率需要匹配接收方应用程序的提取速率 接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间 发送方要限制未确认的数据不超过rwnd 如果rwnd等于0，发送方仍可以发送一个小的报文段，只有一字节，如果确认报文中rwnd不等于0，发送方就可以开始传输数据。 5. TCP拥塞控制 表现： 丢包（路由器缓冲区溢出） 长时延（路由器缓冲区排队） 采用端到端控制，没有网络辅助 控制发送速率：拥塞窗口（cwnd） 感知拥塞 丢失事件：超时或者3个重复ACK 发生丢失，TCP发送方会降低速率 调整发送速率：AIMD（加性增，乘性减） 加性增：如没有检测到丢包事件，每个RTT时间拥塞窗口值增加一个MSS (最大报文段长度) 乘性减：丢包事件后，拥塞窗口减半 慢启动与拥塞避免 慢启动工作过程 连接开始，cwnd = 1 MSS，每当传输的报文段首次确认就增加1个MSS 当连接开始，以指数快地增加速率，直到第一个丢失事件发生。 拥塞避免 设置一个变化的阈值：Threshold 丢包事件发生时，阈值Threshold设置为发生丢包以前的cwnd的一半 慢启动+拥塞避免工作过程 当cwnd&lt; Threshold时，发送者处于慢启动阶段, cwnd指数增长 当cwnd&gt; Threshold时，发送者处于拥塞避免阶段，cwnd线性增长 当出现3个冗余确认时，阈值Threshold设置cwnd/2，并且cwnd设置为Threshold 当超时发生时，阈值Threshold设置为cwnd/2，并且cwnd设置为1 MSS Loss事件处理 3个冗余ACKs：表示网络仍可以传输 超时：拥塞很严重了 网络层 1. 因特网网络层提供服务——尽力而为 分组间的定时不能被保证 分组的接收顺序与发送顺序不一定相同 传送的分组不能保证最终交付，即网络可能未向目的地交付分组 使用协议：IP协议 2. 虚电路网络与数据报网络 区别：两者在建立路由和管理选路方面存在不同 虚电路网络特点 交换机根据虚电路号转发分组 源和目的主机之间先建立虚连接（虚电路） 每个虚电路指定一个标识符 ID 分组带有 ID（VCID），决定下一跳（转发路径） VC路径上每台路由器都有该转发表 不同分组采用同一条路径 数据报网络特点 交换机根据目的地址转发分组。 不需建立连接，无呼叫建立，无端到端连接状态 每个分组带有目的地址，决定下一跳（转发路径） 不同分组可能采用不同路由 虚电路网络工作原理 ① 源和目的之间创建一个VC ② 源向该VC发送带有VC号的分组 ③ 没经过一台路由器，用新的VC号代替原VC号，从VC号转发表获得，每条链路上VC号不同 ④ 依此规则，直到目的地 虚电路网络三个阶段 虚电路建立 ：在发送方与接收方之间建立一条虚电路，即决定所有分组要通过的一系列链路与路由器，并为每条链路确定一个VC号 数据传送 虚电路拆除：由其中一方通知其网络层终止该虚电路 虚电路网络路由器要求 只要该路由器创建新的VC，其转发表中就增加一项 终止一个VC，其转发表中就删除对应项 路由器必须为正在进行的连接维护连接状态信息，直到该连接释放 虚电路网络每条链路采用不同VC号的优点 减少分组首部VC字段的长度 简化虚电路的建立过程 数据报网工作原理 发送方给要发送的分组加上目的端系统地址，并送入网络，经过若干中间路由器转发分组，直到目的地 与运输层的区别 网络层 运输层 服务 向运输层提供主机到主机的服务 向应用层提供进程到进程的服务 实现 网络边缘端系统中 端系统以及网络核心的路由器中实现 连接建立 沿两个端系统之间路径上的路由器都要参与虚电路的建立，且每个路由器都完全知道所经过的所有虚电路 只涉及两个端系统，相互协商通信并共同确定连接的参数。网络中的路由器并不知道该运输层连接 网络层只提供以下两种服务之一：虚电路网络（连接服务），数据报网络（无连接服务） 与链路层的关系 链路层是将网络层的数据报从一个节点传送到下一个节点。不同链路采用不同的链路协议,提供的服务不同 路由 转发概念 将分组从路由器的输入端口转移到合适的输出端口 只涉及分组在路由器中从入链路到出链路的传送 路由概念 确定分组从源到目的经过的路径 涉及网络中的所有路由器，集体经选路协议交互，决定分组从源到目的地的路径 转发方法 通过转发表（每个路由器有一张） 分组首部（目的地址或某个连接标识）和相应输出链路的对照表 转发表的内容由选路算法决定（集中式或分布式） 路由器：根据网络层字段值作转发决定的分组交换机 选路算法 链路状态选路算法——全局选路算法 距离向量选路DV算法——分散式选路算法 层次选路 链路选路算法 前提：已知网络拓扑和所有链路的费用，作为算法的输入 获取方法：每个节点向网络中广播链路状态分组（含有它所连接的链路的费用） 由链路状态广播算法实现。最终使所有节点都有一个相同且完整的网络视图 迪杰斯特拉算法 符号 c(x,y)c(x,y)c(x,y) ：从x到y的链路费用 D(v)D(v)D(v) ：从源节点到目的节点v的当前费用 p(v)p(v)p(v) ：节点 v的前序节点 N′N&#x27;N′ ：已经求出最短路径的节点集合 产生问题 振荡 避免振荡：避免所有路由器同时运行LS算法 DV算法 受控洪泛 所有结点需要将链路状态信息传到其他所有的结点，链路信息包括到邻居结点的连通性以及链路代价，从而每个节点都拥有整个网络的拓扑结构和链路代价值 在传播过程中，需要进行受控洪泛控制，主要方法 在每个分组的首部添加TTL值，没经过一个路由器减一，减为0后路由器将其丢弃。 分组序号依次加一，在每个路由器中记录一个最大序号，如果分组比这个序号小，则说明已经转发过丢弃，如果比序号大就进行转发。 子网划分 划分出的子网需要去掉一个子网地址（子网的第一个）和一个广播地址（最后一个）：如题（1）子网1的可分配地址为202.118.1.1 至202.118.1.126 ，子网地址：202.118.1.0，子网广播地址：202.118.1.127 域名服务器，前32个比特都是前缀（特定主机），子网掩码：255.255.255.255 缺省（默认）路由：0.0.0.0，默认往互联网发送。都匹配不成功的时候会往默认路由发送。 解： （1）把IP地址空间202.118.1.0/24 划分为2个等长的子网，划分结果： ​ 子网1：子网地址为202.118.1.0 ，子网掩码为255.255.255.128（即202.118.1.0/25） ​ 子网2：子网地址为202.118.1.128 ，子网掩码为255.255.255.128（即202.118.1.128/25) ​ 地址分配方案：子网1给局域网1，子网2给局域网2 （2）若子网1分配给局域网1，子网2分配给局域网2 ​ R1路由表如下： 目的网络IP地址 子网掩码 下一跳IP地址 接口 202.118.1.0 255.255.255.128 —— E1 202.118.1.128 255.255.255.128 —— E2 202.118.3.2 255.255.255.255 202.118.2.2 L0 0.0.0.0 0.0.0.0 202.118.2.2 L0 （3）R2的路由表中，到局域网1和局域网2的路由表项如下 目的网络IP地址 子网掩码 下一跳IP地址 接口 202.118.1.0 255.255.255.0 202.118.2.1 L0 目前拥有的地址段为214.97.254/23，请从该地址段起为如下6个子网分配地址，分配形式A.B.C.D/X 网络A 网络B 网络C 网络D 网络E 网络F 250个接口 120个接口 120个接口 2个接口 2个接口 2个接口 层次选路 概念 层次选路：按区域或自治系统的形式组织路由器。将一个大的系统划分成若干小系统（自治系统），自治系统之间再互连。 AS（Autonomous System）：自治系统 同一个AS内的路由器可运行相同的选路算法，且拥有相互之间的信息 自治系统内部选路协议：在一个自治系统内运行的选路算法 自治系统间选路协议：在各AS之间进行选路的选路算法。将分组从一个AS选路到另一个AS 网关路由器：互连各AS，负责转发目的地在本AS之外的分组（将本AS内的分组转发到另一个AS的路由器） 路由器转发表：由AS内部选路协议和AS间选路协议产生 因特网采用层次选路的原因 网络规模的增大导致路由器很多，计算开销、存储以及路由信息的通信增大，进而导致选路计算非常复杂 一个组织可能希望按照自己的愿望运行和管理其网络，又能连接到其他外部网络；而且所有路由器运行相同的选路算法不一定适合某些组织，因此需要管理自治 AS如何划分 自治系统由一组处于相同管理控制下的路由器组成，同一个AS内的路由器可运行相同的选路算法，且拥有相互之间的信息 各包含什么常用的选路协议，协议的特点分别是什么 AS内部选路协议 RIP选路信息协议：基于距离向量的路由协议 OSPF开放最短路径有限：采用迪杰斯特拉最短路径算法，是一种链路状态协议 AS间选路协议 BGP边界网关协议：基于距离向量的路由协议。相邻BGP路由器相互交换路径信息 OSPF协议 区域内（内部）路由器：为信息在区域内的转发提供路由选择 区域边界路由器：为传递到区域外的分组提供路由选择 AS边界（网关）路由器：为传递到自治系统外部的分组提供路由选择 主干路由器：为分组在区域间的路由转发提供路由选择 链路层 链路层提供服务 成帧：网络层数据报封装成帧（加头尾） 链路访问：点对点链路，广播链路 可靠交付 流量控制 差错检测与纠正 全双工与半双工 相邻节点帧的传输 成帧⟶\longrightarrow⟶ 传输帧⟶\longrightarrow⟶ 接收帧 ⟶\longrightarrow⟶ 解封 循环冗余校验码 能检测小于r+1位的突发差错，任意个奇数差错 余数为0，无差错；余数非0，有差错 例：D=101110D = 101110D=101110 ，d=6d = 6d=6，G=1001G = 1001G=1001 解：r=G−1=3r = G - 1 = 3r=G−1=3 ​ D后填三个0，与G进行模二运算，得出余数即为R，将R替换填在D后的3个0即可 多路访问协议 1. 协议概述 TDM——时间帧，N个时隙 FDM——带宽划分为N个小信道 CDMA 随机访问协议 ALOHA协议 CSMA协议 CSMA/CD协议 轮流协议 轮询协议 令牌传递协议 2.时隙ALOHA协议 假设 所有的帧长L 比特 时间被划分为若干等长的时隙（长度为一帧的传输时间L/RsL/R sL/Rs ） 节点只在时隙的开始点传输帧 所有节点同步传输，知道时隙什么时候开始 如果一个时隙有多个节点同时传送，所有节点都能检测到冲突 工作过程 当节点有新的帧要发送，需等到下一个时隙开始，才传输整个帧 无冲突：节点成功传输帧 有冲突：检点检测到冲突后，以概率ppp在后续的每一个时隙重传帧，直到成功 特点 当只有一个活动节点（有帧要发送） 时，以全速RRR （信道全部速率）连续传输 分散的：每个节点检测冲突并独立决定何时重传 发送控制简单 有多个活动节点时效率低 效率 最大效率：$1/e = 0.37 $ N个节点中，任意节点成功传送的概率：N⋅p(1−p)N−1N·p(1-p)^{N-1}N⋅p(1−p)N−1 最低效率：没有任何访问控制，每个节点都在冲突之后立即重传，效率为零 出现时隙的可能情况（参照上图） 冲突时隙C：出现帧冲突，被“浪费”。 空闲时隙E：所有活动节点停止传输，被“浪费”。 成功时隙S：只有一个节点在传输的时隙。 3.纯ALOHA协议 工作过程 节点有帧要发，就立即传输 如果与其他帧产生冲突，在该冲突帧传完之后 以概率p立即重传该帧 或等待一个帧的传输时间，再以概率p传输该帧，或者以概率1-p等待另一个帧的时间 特点 每个节点的传输与广播信道上其他节点的活动是相互独立的 一个节点开始传输时并不知道是否有其他节点正在传输 发生冲突时不会停止传输 效率不高 效率 是时隙ALOHA的一半 4. CSMA协议 载波侦听CS：某个节点在发送之前，先监听信道 信道忙：有其他节点正往信道发送帧，该节点随机等待（回退）一段时间，然后再侦听信道 信道空：该节点开始传输帧 “先听后讲” 原理——传送前侦听 信道闲：传送整个帧 信道忙：延迟传送 特点 发前监听 由于传播时延存在，仍有可能出现冲突，并且造成信道浪费 节点没有进行冲突检测，既使发生了冲突，节点仍继续传输它们的帧，但该帧已经被破坏、是无用的帧，信道传输时间被浪费。 例 时间$$t0$$：节点B侦听到信道空，开始传输帧，沿着媒体传播比特 时间t1t1t1（t1&gt; t0）：节点D有帧要发送。B的传输信号未到D，D检测到信道空，开始传输。很快，B的传输开始在D节点干扰D的传输（冲突） 端到端信道传播时延：信号从一个节点到另一个节点所花费的传播时间。传播时延越长，节点不能侦听到另一个节点已经开始传输的可能性越大。 5. CSMA/CD协议 载波侦听CS：某个节点在发送之前，先监听信道 信道忙：有其他节点正往信道发送帧，该节点随机等待（回退）一段时间，然后再侦听信道 信道空：该节点开始传输帧 冲突检测 CD ：边发送边监听，即节点在传输同时侦听信道 如果检测到有其他节点正在传输帧，发生冲突，立即停止传输，并用某种方法来决定何时再重新传输（类似于不要打断他人说话） 原理——传送前侦听，传输时侦听 - 信道闲：传送整个帧 - 信道忙：延迟传送 - 冲突检测：发送同时进行冲突检测，一旦检测到冲突立刻停止传输，尽快重发 - 目的：缩短无效的传输时间，提高信道的利用率 例 两个节点B、D再检测到冲突之后短时间内都放弃了传输 以太网采用CSMA/CD协议 以太网 1. 以太网提供服务 不可靠的无连接服务 接收到的帧可能包含比特差错 收到正确帧，不发确认帧 收到出错帧，丢弃该帧，不发否定帧 发送适配器不会重发出错帧，传递到接收方网络层的数据报流可能有间隙。需要高层做相应处理 高层处理 使用UDP 使用TCP 以太网并不知道是传输新数据，还是重传数据 2. CSMA/CD：以太网的多路访问协议 机制 未使用时隙：适配器可以在任何时刻开始传输 使用载波侦听：当适配器侦听到有其他的适配器在传输，就不会传输帧 使用冲突检测：当检测到其他适配器也在传输帧，就中止传输 侦听和冲突检测，由以太网适配器通过测量传输前和传输过程中的电压等级来进行 重传：冲突后，等待一个随机时间（小于传输一帧的时间），再重传 各适配器独立运行CSMA/CD协议，不需和其他适配器进行协调 工作过程 ① 封装成帧 发送适配器从父节点获得一个网络层数据报，封装成以太网帧，放到缓冲区中 ② 适配器侦听信道 空闲：即在96比特时间内，没有信号从信道进入，开始传输该帧 忙：等待，直至侦听不到信号 (加上96 比特时间)，开始传输该帧 ③ 无冲突成功传输 整个帧传输期间未检测到其他适配器的信号，该帧传输成功 ④ 有冲突停止传输 传输时检测到其他适配器的信号，就停止传输帧，并传输一个48 比特的拥塞信号 ⑤ 等待随机时间再侦听 传输拥塞信号后，适配器进入指数回退阶段，等待一段时间，并返回到第2步 拥塞信号作用 强化冲突信号，使所有其他的传输适配器都知道发生冲突 指数后退算法 基本后退时间：以512 比特时间为单位 第n次冲突后退让时间：K×512K × 512K×512 比特时间 K与冲突次数有关，是{0 至 2^m -1} 之间的一个随机整数 m=min(n,10)m = min(n, 10)m=min(n,10) 说明 限制任意两个节点之间的距离 确保当一个适配器选择了比其他冲突的适配器都要低的K值时，能够成功传输，而不会遇到新的冲突 采用指数回退等待，减少冲突 适配器每传输一个帧，都要运行CSMA/CD算法 适配器发送新帧时，不考虑最近发生的任何冲突 当发生冲突的适配器处于指数回退状态时，冲突外的适配器有可能成功的传输一个新帧 ARP 例题：叙述图示中A节点如何利用ARP完成与B节点的通信过程（网络层与数据链路层角度） （A知道B的IP地址）(20’) 关注点 IP地址（数据报中）和MAC地址（帧中） A如何得知第一跳路由器R左接口IP地址？——默认网关 A如何得知第一跳路由器R左接口MAC地址？——ARP协议 改变的是MAC地址 公共互联网与内网交换时才会改变IP地址 ① A将B的IP地址与A的子网掩码相与，发现不在同一个网段中，需要通过配置的默认网关路由111.111.111.110进行转发。 ② 获取111.111.111.110 的MAC地址。节点A向它的适配器传递一个ARP查询分组，并要求适配器用MAC广播地址（FF-FF-FF-FF-FF-FF）发送分组，适配器在链路层帧中封装该ARP分组，并将该帧传入子网，111.111.111.110 的路由器接口在收到该帧后，给A返回一个带有它的MAC映射的ARP分组。 ③ A收到②中的ARP分组后更新它的ARP表，并将源IP为A（111.111.111.111），目的IP为B（222.222.222.222）的数据报封装在源MAC为A（74-29-9C-E8-FF-55）目的MAC为路由器左端接口MAC地址（E6-E9-00-17-BB-4B）的链路层帧中，经过适配器发送到子网1中。 ④ 子网1的路由器适配器发现该链路层帧是向它寻址的，因此把它传给路由器的网络层，路由器通过查询转发表，得知该数据报需要通过的路由器接口为222.222.222.220 ，于是它把数据报传递给适配器，适配器将该数据报封装到新的帧中，适配器通过ARP表查到B的MAC地址，并且将它作为该帧的目的MAC地址，把R的MAC地址作为源MAC地址，然后将该帧发送到子网中。 ⑤ B的适配器发现该链路层帧是向它寻址的，因此把它传给网络层。 WEB页面请求历程 思路 获得自身IP地址（从DHCP服务器获得） 查询要访问网站的IP地址（ARP查询获得路由器的MAC地址、 路由器运用RIP、OSPF、BGP选路将IP数据报发往本地DNS服务器、DNS查询全过程得目的网站IP） TCP三次握手建立连接进行客户-服务器交互 ① 将包含DHCP请求报文的IP数据报放置在以太网帧中，源MAC为发送主机MAC，目的MAC全F，广播到与交换机连接的所有设备。 ② DHCP服务器给它分配地址，发送包含生成IP地址、DNS服务器IP地址、默认网关路由器IP地址、子网掩码的DHCP ACK报文。 ③ 发送主机发送ARP查询报文，目的IP地址为默认网关路由器地址，目的MAC地址全F到交换机，交换机发给所有连接设备，包括网关路由器。网关路由器将ARP回答放入一个以太网帧中发回去。 ④ 发送方主机发送DNS查询报文，目的IP为本地DNS服务器，MAC地址为网关路由器。 ⑤ 一系列DNS查询过程后，得到目的主机IP。 ⑥ 发送TCP SYN报文段，目的IP为目的主机，MAC地址为网关路由器。使用每台路由器中的转发表及BGP协议决定最短路径发往目的主机。 ⑦ 目的主机发送TCP SYNACK报文段给请求主机，将其放入一个向源主机选址的数据报中，到达源主机以太网卡后在操作系统中分解的到生成的套接字，进入连接状态。 ⑧ 源主机的浏览器生成包含要获取的URL的HTTP GET报文，目的主机的HTTP服务器从TCP套接字读取HTTP GET报文并生成HTTP响应报文发回。 简答题 1. 什么是协议？协议分层的好处是什么？详细描述TCP/IP协议栈5个层次的功能及相关协议。（5‘） 什么是协议: 协议定义了两个或者多个通信实体间交换的报文格式和次序，以及报文发送、接受一条报文或者其他事件所采取的动作。 协议分层优点: 概念化，便于了解协议的规范细节 结构化，各层之间独立，易于实现和维护 模块化，减少耦合度，便于更新系统组件 TCP/IP协议栈5个层次的功能及相关协议: 应用层：端系统间应用程序交换报文的协议 运输层：在端点之间传送应用层报文 网络层：负责在主机之间传送数据报 数据链路层：负责结点到结点的数据交付 物理层：负责将帧中的每个比特传送到下个结点 2. 因特网为什么采用层次选路？AS是如何划分的？各包含什么常用的选录协议？协议的特点分别是什么？自治系统F收到其他自治系统的信息如下图，请阐述F依次通过什么策略决定其内部路由配置的？（10’） 规模的不断增大使得路由信息的计算、通信、存储开销变大； 管理自治的需求要求一个组织可以按照自己的愿望运行和管理网络。 自治系统由一组处于相同管理控制下的路由器组成 RIP协议：距离向量协议 OSPF协议：包含洪泛链路状态信息链路状态协议 和 迪杰斯特拉算法 BGP协议：通过外部BGP 会话获取可达信息、通过内部BGP会话在AS内部传播信息 本地偏好值-&gt;由管理员决定的策略 自治系统间路由选择、自治系统内部的路由选择 2.1因特网为什么采用层次选路？AS是如何划分的？各包含什么常用的选录协议？协议的特点分别是什么？下图中的OSPF的路由器作用分别是什么？（15’） 3. 访问因特网时，为什么你的带宽远远低于实际带宽？请详细分析原因。（5‘） 排队时延、处理时延、传输时延、传播时延 网路信道的丢包事件 流量控制、拥塞控制 3.1 假定你的带宽是100M的，为什么你的访问带宽远远低于实际物理带宽？请详细分析原因。（5’） 4. 请描述通过手动查询本地DNS对www.weihai2018.com解析的过程，并详细描述如何获取层次结构的组成及其各层次功能。（10’） DNS服务器类别 域名 IP 顶级域名服务器 d.gtld-servers.net 192.31.80.30 根名称服务器 c.root-servers.net 192.33.4.12 权威名称服务器 Ns1.weihai.2018.com 61.135.165.235 本地名称服务器 ns.sdjnptt.net.cn 202.102.128.68 www.weihai2018.com 61.135.169.125 ① 本地主机首先向本地DNS服务器请求解析www.weihai2018.com的IP地址如果本地DNS服务器上存在该网站信息，就直接返回。 ② 如果本地DNS无法解析，则向根域名服务器请求能够解析.com域名的顶级域名服务器。 ③ 本地DNS得到顶级域名服务器IP地址后，继续向其发送请求，获取能够解析weihai2018.com的权威名称服务器。 ④ 本地DNS得到权威名称服务器ip地址后，继续向其发送请求，获取www.weihai2018.com的IP地址，本地DNS存储后在将结构返回给本地主机。 4.1 DNS服务的层次结构中各层之间的相互作用是什么？请描述在本地DNS上，如何通过手动查询www.CNN.com解析过程。（10‘） 5. 请描述主机H1发送数据到主机H3的转发过程，在描述转发过程中请考虑网络层及数据链路层的转发处理。注意本图为初始状态，主机及路由中尚未形成ARP表。（15‘） ① 通过子网掩码对IP进行与运算，得到所在子网，判断H1和H3不在一个网关内，需要跨越网关。 ② 通过arp协议向网关内广播，网关收到广播协议后通过arp协议告诉H1本地的网关地址R10。 ③ 通过数据链路层完成H1到R10的点对点提交，其中源MAC是H1，目的MAC是R10，源IP是H1，目的IP是H3。 ④ 路由器R1收到分组后通过查找转发表来将分组递交到subnet2的R11。 ⑤ R11通过相同的步骤判断和H3不在同一个网关内，然后通过arp协议获取R20的MAC地址,并将分组递交到R20。 ⑥ R20通过路由转发将分组递交到subnet3的R21，判断出H3在同一网关内。 ⑦ R21通过arp协议广播获得H3的MAC地址，然后将分组递交给H3，网络层将分组递交到上层。 6. 详细描述TCP拥塞控制算法（三个主要部分的详细描述） 慢启动 ① 每过一个RTT，拥塞窗口翻倍，指数增长 ② 发生丢包事件，ssthresh（阈值）=crwd/2 cwnd=1 重新慢启动 ③ 发生冗余ACK， ssthresh=crwd/2 进入快速恢复 ④ cwnd接近阈值时，进入拥塞避免 拥塞避免 ① 每过一个RTT,拥塞窗口值加一 ② 发生丢包事件，ssthresh（阈值）=crwd/2 cwnd=1 重新慢启动 ③ 发生冗余ACK， ssthresh=crwd/2 进入快速恢复 快速恢复 ① 发生丢包事件，ssthresh（阈值）=crwd/2 cwnd=1 重新慢启动 ② 丢失报文段的ACK到达时cwnd = ssthresh 进入拥塞避免 7. 请根据下图详细分析笔记本（原来没有IP、网关、DNS信息、ARP表）如何动态加入校园网并且通过浏览器访问www.google.com网站的全过程（请从DHCP分配IP、域名解析、外网访问、HTTP及TCP协议通信过程的角度，按处理先后顺序进行分析描述） 请求文本页面的过程 笔记本运行DHCP协议来获取动态地址，发送DHCP请求报文，其中目的端口67（DHCP服务器）源端口68（DHCP客户）目的IP（255.255.255.255）源IP（0.0.0.0）目的MAC FF:FF:FF:FF:FF:FF 源MAC是笔记本MAC。DHCP服务器返回ack报文，包括分配的ip，DNS服务器ip，网关ip，网络掩码。 通过以太网帧递交给客户机 ① 客户机运行DHCP协议，发送DHCP请求报文，通过广播来发送给DHCP服务器，然后获取DHCP响应报文，同时路由器自学习交换机表。 ② 客户机运行arp协议，通过广播包和网关路由器ip地址来获取网关MAC地址， ③ 客户机输入URL地址，然后运行DNS协议来解析域名，发送包含DNS解析的UDP报文。 ④ DNS解析报文通过自治系统间网络协议和自治系统内部网络协议最终到达DNS.server服务器，然后服务器返回域名解析结果 ⑤ 根据DNS解析的结果，客户机通过三次握手建立和服务器之间的tcp连接。 ⑥ 客户机中的应用程序通过套接字将http请求报文向下递交给tcp，然后通过tcp连接发给服务器，并获取http响应报文，然后从响应报文中抽取HTML文本，浏览器解析渲染生成网页。 8. 简述虚电路网络和数据报网络的特点。（5’） 是否需要建立连接 分组到达顺序不同 分组转发路径不同 结点故障不同 虚电路号和完整地址 差错处理和流量控制 9. TCP可靠数据传输的发送方和接收方各有什么特点？接收方受到错误或乱序的数据包如何处理？（5‘） 10. 简述以太网中CSMA/CD协议工作过程。（10’） ① 适配器首先通过网络层获取数据报，准备链路层帧放入帧适配器缓存中。 ② 如果适配器监听到信道空闲则开始传输帧，如果信道忙，则一直监听到信道空闲再开始传输 ③ 在适配器传输过程中监视来自其他使用广播信道的适配器的信号能量的存在。 ④ 如果传输过程中没有检测到其他适配器的信号能量，则完成传输。 ⑤ 如果传输过程中检测到其他适配器的信号能量，则终止传输，利用二进制指数后退方法确定等待时间，然后重新返回步骤二传输。 11.请用链路状态算法求节点到所有目的节点（迪杰斯特拉） 计算题 1. 循环冗余校验码 2. 分配子网 3. 最短路径]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构重点知识]]></title>
    <url>%2Fliysuzy%2F2019%2F11%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[第四章 树与二叉树 考试大纲： a: 二叉树的定义、性质、表示、遍历算法 b: 树的表示、操作算法 c: 森林与二叉树关系 d: 树与二叉树的应用及算法 重要名词 树【概念】：度，结点的深度、高度、层次，有序/无序树，两结点间路径、路径长度，森林。 树【存储】：双亲表示法、孩子表示法、孩子兄弟表示法。 树【遍历】：（树）先根遍历、后根遍历。（森林）先序遍历、中序遍历。 树【应用】：并查集 二叉树【概念】：满二叉树、完全二叉树、二叉排序树、平衡二叉树、★线索二叉树。 二叉树【存储】：顺序存储结构、链式存储结构。 二叉树【遍历】：先序遍历、中序遍历、后序遍历、层次遍历。 二叉树【应用】：二叉排序树（定义、插入、查找、构造、删除、效率分析）、平衡二叉树（定义、插入[旋转]、查找）、哈夫曼树与哈夫曼编码。 第五章 图 考试大纲： a: 图的相关概念 b: 图的存储结构与搜索算法 c: 图的应用及算法 重要名词 【概念】：[ 有向图中的概念 ]，{ 无向图中的概念 } 有向图、无向图、简单图、多重图、完全图； 子图、生成子图、导出字图、主子图； { 连通、连通图、连通分量 }、[ 强连通图、强连通分量 ]、极大连通子图、极小连通子图；生成树、生成森林； 顶点的度、入度、出度；边的权、网；稠密图、稀疏图； 路径、路径长度、回路、简单路径、简单回路；距离；有向树。 【存储】：邻接矩阵、邻接表、十字链表、邻接多重表。 【遍历】：广度优先搜索（BFS）、深度优先搜索（DFS） 【应用】： 最小生成树：Prim, Kruskal 最短路径：Dijkstra （单源）, Floyd（每对顶点之间） 拓扑排序——AOV网（顶点表示活动） 关键路径——AOE网（边表示活动） 图的有关性质 $ &lt; v , w &gt; $ 表示 $ v \rightarrow w $ ， $ v $ 为弧尾， $ w $ 为弧头。 有含有 $ n $ 个顶点的有向完全图有 $ n (n-1) $ 条边，含有 $ n $ 个顶点的无向完全图有 $ \frac{n (n-1)}{2} $ 条边。 路径是顶点序列。 无向图若 $ v \rightarrow w $ 有路径存在，那么 $ v,w $ 是连通的。有路径≠有弧，有路径指的是v可以经过其他点到w。 极大连通子图就是无向图中的连通分量。极大连通子图要求该连通子图包含其所有的边；极小连通子图是既要保持图的连通又要使边数最少的子图。无向图中，一个图有 $ n $ 个顶点，并且边数小于 $ n - 1 $ ，则必为非连通图。 有向图若 $ v \rightarrow w $ $ v \leftarrow w $ 均存在，那么 $ v,w $ 是强连通的。任何一对顶点都是强连通的，则此图为强连通图。极大强连通子图就是有向图中的强连通分量。 连通图有 $ n $ 个顶点，则它的生成树含 $ n - 1 $ 条边。砍去一条边则变为非连通图，加上一条边会形成回路。 无向图中全部顶点的度数之和等于边数的两倍。 有向图中，一个顶点的度等于其入度与出度之和。有向图中全部顶点的入度之和等于全部顶点的出度之和。 十字链表 （ Orthogonal List ）是有向图的邻接表和逆邻接表结合起来得到的。 每条有向弧都有一个节点，对应的每个顶点也有一个节点。 入弧和出弧：入弧表示图中发出箭头的顶点，出弧表示箭头指向的顶点。 弧头和弧尾：弧尾表示图中发出箭头的顶点，弧头表示箭头指向的顶点。 同弧头和同弧尾：同弧头，弧头相同弧尾不同；同弧尾，弧头不同互为相同。 图的十字链表不唯一，但是一个十字链表确定一个图 画十字链表示例 第一步，画出所有顶点，并且为其编号 第二步，画出所有边，按照标号。以 $ b $ 节点为例， $ b \rightarrow a $ ，$ a $ 为弧头， $ b $ 为弧尾，因此先写 $ 1 $ ，再写 $ 0 $ ，将弧尾与顶点相同的放在一行，同理还有 $ b \rightarrow c $ 。 第三步，将顶点的入弧与指向自己的那条边连接起来，将出弧与自己指向出的那条边连接起来。如果同一个顶点有多个出边，则连接这一行。即同弧头指向本列，同弧尾指向本行 。并且将空节点填入 ^ 邻接多重表 是无向图的一种存储结构 每条边用一个节点表示 BFS（广度优先搜索） 算法描述： 广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。(CSDN卡巴拉的树) 首先选择一个顶点作为起始结点，并将其染成灰色，其余结点为白色。 将起始结点放入队列中。 从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部，将已访问过结点涂成黑色，没访问过的结点是白色。如果顶点的颜色是灰色，表示已经发现并且放入了队列，如果顶点的颜色是白色，表示还没有发现。 按照同样的方法处理队列中的下一个结点。 基本就是出队的顶点变成黑色，在队列里的是灰色，还没入队的是白色。 算法执行过程： 从顶点1开始进行广度优先搜索： 初始状态，从顶点1开始，队列={1} 访问1的邻接顶点，1出队变黑，2,3入队，队列={2,3} 访问2的邻接结点，2出队，4入队，队列={3,4} 访问3的邻接结点，3出队，队列={4} 访问4的邻接结点，4出队，队列={ 空 } 结点5对于1来说不可达。 DFS（深度优先搜索） 算法描述：深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。 初始条件下所有节点为白色，选择一个作为起始顶点，按照如下步骤遍历： 选择起始顶点涂成灰色，表示还未访问。 从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，直到一个顶点没有邻接结点了，涂黑它，表示访问过了。 回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层。 上一层继续做如上操作，知道所有顶点都访问过。 算法执行过程： 初始状态，从顶点1开始 依次访问过顶点1,2,3后，终止于顶点3 从顶点3回溯到顶点2，继续访问顶点5，并且终止于顶点5 从顶点5回溯到顶点2，并且终止于顶点2 从顶点2回溯到顶点1，并终止于顶点1 从顶点4开始访问，并终止于顶点4 最小生成树 不唯一，仅当图的各边权值互不相同时，才是唯一的 最小生成树边的权值之和总是唯一的，并且是最小的 最小生成树的边的个数为顶点个数减一 Prim（普里姆）算法 让一棵小树长大 找一条权值最小的边，其两顶点一个是已包含的顶点，一个是未包含的顶点，找到后将其从未包含顶点移除加入已包含顶点。 时间复杂度：$ O(|V|^2) $ ，不依赖 $ |E| $ 适合边稠密的图 Kruskal（克鲁斯卡尔）算法 将森林合并成树 按权值递增的次序寻找合适的边（不构成回路），直到找到n-1条边。 时间复杂度： $ O(|E|Log|E|) $ 适合边稀疏但是顶点多的图 Dijkstra（迪杰斯特拉）算法 求某源点到其余各点的最短路径 边上不允许有负权值 时间复杂度： $ O(|V|^2) $ 路由选择算法——链路状态路由选择算法（ LS ） $ D(v) $ ：到算法的本次迭代，从源结点到目的节点 $ v $ 的最低费用路径的费用。 $ p(v) $ ：从源节点 v 沿着当前最低费用路径的前一节点（ $ v $ 的邻居） $ N’ $： 节点子集； 如果源到 v 的最低费用路径已经确知， $ v $ 在 $ N’ $ 中 步骤 N’ D(v) , p(v) D(w) , p(w) D(x) , p(x) D(y) , p(y) D(z) , p(z) 0 u 2 , u 5 , u 1 , u ∞ ∞ 1 ux 2 , u 4 , x 2 , x ∞ 2 uxy 2 , u 3 , y 4 , y 3 uxyv 3 , y 4 , y 4 uxyvw 4 , y 5 uxyvwz 追溯：例如如何找 $ u \rightarrow w $ 的最短路径？ 找对应 $ p[w] $ 一列，最后一个节点为 $ y $ , 然后找 $ p[y] $ 一列，最后一个节点为 $ x $ ，然后找 $ x $ 一列，最后一个节点为 $ u $ , 因此 $ u \rightarrow w $ 的最短路径为 $ u \rightarrow x \rightarrow w $ 。 不可以遍历 $ p[w] $ ，找 $ w $ 之前的节点，因为如图所示，遍历结果为 $ u x y v w $ , 并没有 $ v $ 。 Floyd（弗洛伊德）算法 任意两点之间的最短路径 允许有负权值的边，但不允许有包含负权值的边组成的回路。 时间复杂度： $ O(|V|^3) $ Floyd 是一个递推过程。 路由选择算法——距离向量算法（ DS ） 拓扑排序 所有的顶点表示活动，顶点之间的边表示活动的先后顺序。这样的图称为AOV网。 拓扑序：若 $ v \rightarrow w $ 之间有一条有向路径，则 $ v $ 一定排在 $ w $ 之前。拓扑排序：获得一个拓扑序的过程。 AOV 如果有合理的拓扑序，则必定是有向无环图（DAG）。 拓扑排序流程： 每个顶点仅出现一次，A在B之前则不存在B指向A的边 ① 从 DAG 中选择一个没有前驱节点（入度为0）的点。 ② 从图中删除该顶点和所有以它为起点的有向边。 重复①②步骤直到当前的 DAG 图为空或者当前图中不存在无前驱的顶点为止。 如果一个图的邻接矩阵为三角矩阵，则存在拓扑序列；反之则不一定成立。 拓扑排序时间复杂度： $ O(|V|+|E|) $ 关键路径 AOE 网：有向图用边表示活动的网络。 只有在某个顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才可以开始。 只有在进入某一顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。 AOE网中只有一个入度为0的点，为开始顶点（源点）；只有一个出度为0的点，为结束顶点（汇点）。 计算Earliest，以1，2，4为例 ① $ \rightarrow $ ④ 的权值为1，① 最早开始时间为6，② $ \rightarrow $ ④ 的权值为1，② 最早开始时间为4， 则 ④ 的最早开始时间：Max{ 1+6, 1+4 } = 7 ，递推式： $ Earliest [0] = 0 $ $ Earliest[j] = Max_{&lt;i,j&gt;∈E} { Earliest[i] + C_{&lt;i,j&gt;} } $ 计算Earliest，以4，5，7为例 ⑦ 的最晚开始时间为14，④ $ \rightarrow $ ⑦ 需要7 天，因此最晚开始时间 14 - 7 = 7，同理可得⑤的最晚开始时间为10，④必须在⑤完成后才可以进行，因此⑤的最晚开始时间为 14 - 7 - 0 = 7（走 ⑤ $ \rightarrow $ ④ $ \rightarrow $ ⑦ ），递推式： $ Latest [8] = 18 $ $ Latest[j] = Min_{&lt;i,j&gt;∈E} { Latest[j] - C_{&lt;i,j&gt;} } $ 机动时间：哪些组有休息时间。比如 ② $ \rightarrow $ ④， ② 最早第4天就开工，最晚在第7天完工，而只需要一天就可以完成任务，因此有 7 - 4 - 1 = 2天是空余的，因此有两天的机动时间，推导式： $ D_{&lt;i,j&gt;} = Latest[j] - Earliest[i] - C_{&lt;i,j&gt;} $ 关键路径：哪些组绝对不允许延误，一旦耽误将使整个项目延期的路径。关键路径不止一条，没有机动时间的路径从从第一个顶点到最后一个顶点连接就是关键路径。 关键路径：从源点到汇点的所有路径中，具有最大路径长度的路径。 关键活动：关键路径上的所有活动。 关键路径并不唯一。有几条关键路径的网，仅仅提高一条关键路径上的关键活动不能缩短整个工程的周期！ 第六章 查找 考试大纲： a: 查找与排序的相关概念 b: 典型算法的描述及复杂性分析 c: 查找与排序算法的应用 重要名词 【基本概念】：静态查找、动态查找 【线性结构】：顺序查找、折半查找、分块查找 【树形结构】：二叉排序树、二叉平衡树、B树、B+树 【散列结构】：散列表 【效率指标】：平均查找长度——ASL B树 1. 概念 B树是多路平衡查找树。 阶：B树中所有结点的孩子节点数的最大值称为B树的阶，通常用m表示。 一棵m阶B树，要么是空树，要么是满足以下特性的m叉树： 树中每个结点至多有m棵子树（即至多m-1个关键字） 若根节点不是终端节点，则至少有两棵子树。 除根结点之外的所有非叶节点至少有 $ \lceil{ \frac{m}{2} } \rceil $ 棵子树（即至少含有 $ \lceil{ \frac{m}{2} } \rceil - 1 $ 个关键字） 非叶节点的结构，这一条是保证B树是有序的，如下面的3阶B树： 所有叶节点都出现在同一层次上，并不带任何信息，也不能算做一层。因此一定是一棵平衡树，平衡因子是0。 如下图3阶B树： 每个结点最多3棵子树，最多2个关键字。至少有 $ \lceil{ \frac{3}{2} } \rceil = 2 $ 棵子树，至少有1个关键字。 每个结点内部是有序的，比如 18 &lt; 33, 20 &lt; 21；并且结点左子树的所有值都要比节点最小值小，结点右子树的所有值要比结点最大值大，结点的中间子树的所有值都要比结点最小值大、比节点最大值小。 2. n个关键字，阶数为m，高度为h的B树，三者之间的关系（★★★） h 最小：每个结点的关键字数量最大即可。即 $ n ≤ (m-1)(1+m+m2+…+m{h-1}) $ $ 1+m+m2+…+m{h-1} $ 是计算满m叉树有多少结点。第一层有一个结点，第二层有m个结点，第三层有m*m个结点，以此类推。$ m - 1 $ 意为每一个结点最多有 $ m - 1 $ 个关键字。这样就计算了当B树为满的时候最多有多少个关键字。$ (m-1)(1+m+m2+…+m{h-1}) = m^h - 1$ ，两边取对数，得到 $ h ≥ log_{m} (n-1) $ h 最大：每个结点的关键字数量最少即可。根节点至少有两棵子树，一个关键字，因此设根节点有一个关键字，两棵子树。设两棵子树的结点为A,B。根据除根结点之外的所有非叶节点至少有 $ \lceil{ \frac{m}{2} } \rceil $ 棵子树 ，我们可以得到A，B均至少有 $ \lceil{ \frac{m}{2} } \rceil $ 棵子树 ，所以第三层至少有 $ 2 \lceil{ \frac{m}{2} } \rceil $ 棵子树，以此类推，第h+1层至少有 $ 2 (\lceil{ \frac{m}{2} } \rceil)^{h-1} $ 个结点。由于h+1层是不包含任何信息的叶节点，且对关键字个数为n的B树，叶节点（及即查找不成功的结点）为n+1，因此 $ n + 1 ≥ 2 (\lceil{ \frac{m}{2} } \rceil)^{h-1} $ ，得到 $ h ≤ log_{\lceil{ \frac{m}{2} } \rceil} (\frac{n+1}{2}) + 1 $ 例如，对于一棵3阶B树共有8个关键字，则其高度范围为 2 ≤ h ≤ 3.17。 3. 查找 与二叉查找树很相似。 ① 在B树中找节点。（通常在磁盘上进行） ② 在结点内找关键字。（通常在内存中进行） 4. 插入 ① 定位。利用B树的查找算法，找出插入该关键字的最低层中的某个非叶节点。（B树中的插入关键字一定插入在最低层中的某个非叶节点） ② 插入。B树中，除根结点之外的所有非叶结点至少含有 $ \lceil{ \frac{m}{2} } \rceil - 1 $ 个关键字，至多 $ m-1 $ 个关键字。因此每个非失败结点的关键字都在区间 $ [ \lceil{ \frac{m}{2} } \rceil - 1, m - 1 ] $ 内。插入后的结点关键字个数小于m（严格小于），可以直接插入；当插入后的结点关键字个数大于m-1时，必须对结点进行分裂。 分裂的方法：将关键字个数大于m-1的结点从中间位置将其中的关键字分为两部分，左部分包含在该关键字的原结点中，右部分包含在一个新结点中，中间位置 $ \lceil{ \frac{m}{2} } \rceil $ 的结点插入原结点的父节点 如果此时导致父节点的关键字个数也超过上限，则继续进行这种操作，知道这个过程传到根节点为止。如果这种情况出现的话，会导致B树的高度增1。 插入13时，如图，属于正常插入。 插入19，如图，需要分裂。 向上分裂。 分为三部分，19、20、21，19放在原结点，20放入父节点，21放到原结点的右侧。 父节点也不符合B树要求，因此继续向上分裂。 最终导致树的高度增一。 5. 删除 当被删除关键字在终端节点（最低层非叶节点）中时： 直接删除关键字。如果被删除关键字所在结点的关键字个数 $ &gt; \lceil{ \frac{m}{2} } \rceil - 1 $ 时，表明删除关键字后仍然满足B树的定义，可以直接删除。 兄弟够借。若被删除关键字所在结点关键字总数 $ = \lceil{ \frac{m}{2} } \rceil - 1 $，且与此结点邻近的右（左）兄弟结点的关键字个数 $ ≥ \lceil{ \frac{m}{2} } \rceil $，则需要从兄弟结点借一个关键字，此过程需要调整该结点、右（左）兄弟结点和双亲结点（父子换位法）的关键字，以达到平衡。 如：删除24，发现删除后不满足B树要求（双亲结点右两个关键字。则必须右三棵子树），发现左兄弟结点可以借（关键字个数大于等于 $ \lceil{ \frac{3}{2} } \rceil = 2 $ ），采用兄弟够借。 右兄弟结点也满足要求，因此也可以向右兄弟节点借。 若被删除关键字所在结点关键字个数 $ = \lceil{ \frac{m}{2} } \rceil - 1 $ ，且与此结点邻近的兄弟结点的关键字个数 $ = \lceil{ \frac{m}{2} } \rceil - 1 $ ，则删除关键字，并与一个不够借的兄弟结点和双亲结点中两兄弟子树中间的关键字合并。 合并后若双亲结点因减少一个结点导致不符合定义，则继续执行2、3步骤。 如：删除30，发现左右兄弟均不够借。因此需要将一个兄弟、双亲结点中两兄弟子树中间的关键字合并。 当被删除关键字在非终端节点中时： 若小于k的子树中关键字个数 $ ＞ \lceil{ \frac{m}{2} } \rceil - 1 $ ，则找出k的前驱值k’，并用k’来取代k，再递归地删除k’即可。 如：删除33，找33的前驱节点32，将33与32替换，将32删除即可。 若大于k的子树中关键字个数 $ ＞ \lceil{ \frac{m}{2} } \rceil - 1 $ ，则找出k的后继值k”，并用k’来取代k，再递归地删除k”即可。 如：删除33，找33的后继节点45，将33与45替换，把33删除即可。 若前后两子树关键字个数均为 $ \lceil{ \frac{m}{2} } \rceil - 1 $ ，则直接两个子结点合并，然后删除k即可。 如：删除23，发现23的左子树21，右子树24关键字个数正好为 $ \lceil{ \frac{3}{2} } \rceil - 1 = 1 $ ，因此将两个子节点合并，删除23即可。 散列表 1. 名词 散列函数，散列表 散列函数： 直接定址法：不会产生冲突 除留余数法 数字分析法 平方取中法 折叠法 处理冲突的方法： 开放定址法 线性探测法：会造成大量元素堆积 平方探测法：避免堆积，但是只能探测到一半单元 再散列法 伪随机序列法 拉链法（链地址法） 散列表的查找效率取决于： 装填因子（装满程度） 散列函数 处理冲突的方法 2. 复杂度 时间复杂度： $ O(1) $ ，与表中元素的个数无关。 堆积现象会影响平均查找长度。 KMP算法 学习自自b站大佬——正月点灯笼 主串： $ abaacababcac $ , 匹配字串： $ ababc $ 1. 字符串的前缀，后缀、部分匹配值 前缀：除了最后一个字符以外，字符串的所有头部字串。 后缀：除了第一个字符以外，字符串的所有尾部字串。 部分匹配值：前缀和后缀的最长的共有元素的长度 对 $ ababa $ 求前后缀： 前缀： $ {a, ab, aba, abab} $ 后缀：$ {a, ba, aba, baba} $ 最长公共前后缀为 $ aba $ ，因此部分匹配值为3 2. KMP算法原理 减少模式串回溯的距离 &quot;部分匹配&quot;的实质是，有时候，字符串头部和尾部会有重复。比如，“ABCDAB&quot;之中有两个&quot;AB”，那么它的&quot;部分匹配值&quot;就是2（&quot;AB&quot;的长度）。搜索词移动的时候，第一个&quot;AB&quot;向后移动4位（字符串长度-部分匹配值），就可以来到第二个&quot;AB&quot;的位置。 —— 来源 3. KMP算法步骤 第一步：写出所有的前缀，把每个前缀当作独立的串，分别求部分匹配值 ​ 部分匹配值我写在了串的前面，最后一个串 $ ababc $ 不是前缀也不是后缀，可以不写。 $ a $ , 没有前后缀，部分匹配值为0 $ ab $ , 前缀为 $ {a} $ , 后缀为 $ {b} $ , 没有公共前后缀，部分匹配值为0 $ aba $ , 前缀为 $ { a, ab} $ ，后缀为 $ {a, ba} $ ，公共前后缀为 $ {a} $ ，部分匹配值为1 以此类推 第二步：写前缀表 ，将主串拆为单个字符，将部分匹配值表右移一位，写在主串下面，第一位用-1代替。 字符 a b a b c 部分匹配值 0 0 1 2 0 右移 -1 0 0 1 2 第三步：为字符分配下标。如果下标从0开始，则与上一个表相同。于是前缀表为： next数组下标 0 1 2 3 4 字符 a b a b c next数组值 -1 0 0 1 2 如果下标从1开始，则将“右移“行的每一项加1，于是前缀表为 next数组下标 1 2 3 4 5 字符 a b a b c next数组值 0 1 1 2 3 我们以从**-1开始的next数组为例**，称上面的表为前缀表。 第四步：匹配 原则：当主串为 $ p $ 、字串为 $ q $ 时匹配失败，则查看前缀表中 $ q $ 字符对应的next数组值 $ k $ ，则将**next[k]**对应的字符与主串中的 $ p $ 对应，从 next[k] 对应的字符继续匹配。 当主串为a、字串为b时匹配失败（如下图），则查看前缀表中b字符对应的next数组值1，则将next[1]对应的字符b与T中的当前字符a对齐，从该字符继续匹配。 可见仍然匹配错误，再按照刚才的方法，当主串为a、字串为b时匹配失败（如下图），则查看前缀表中b字符对应的next数组值0，则将next[0]对应的字符a与T中的当前字符a对齐，从该字符继续匹配。 a-a匹配成功，c-b匹配失败，继续按照上面的方法进行。 发现c-a仍然匹配失败，next[0]数组值为-1，因此直接将P右移一位即可。 匹配成功。 如果要继续匹配，则取P最后一位c的next数组值next[4]=2，将数组下标为2的字符a与T中的c对应。从a开始继续往后匹配。 4. 复杂度 时间复杂度 $ O(m+n) $ , m、n分别是主串和模式串的长度。 5. KMP算法与普通模式匹配的比较 普通匹配模式的时间复杂度为 $ O(mn) $ ， KMP时间复杂度 $ O(m+n) $ 。其实在一般情况下，普通模式匹配的实际执行时间也近似为$ O(m+n) $ ，因此至今仍然被采用。 KMP算法仅在主串与字串有很多”部分匹配“的时候才显得比普通算法快得多，主要优点在于主串不回溯。 第七章 排序 动画来自@五分钟学算法 可视化排序来自B站 一、概念 任何基于比较的排序，对任意n个关键字的排序比较次数至少为 $ \lceil log_2(n!) \rceil $ 算法的稳定性与算法的优劣无关 当待排序数据基本有序时，对快排最不利。 二、插入排序 直接插入排序 直接插入排序可视化 将当前要排序的元素L(i)插入有序序列中。 如图，待排序序列3，6，7，4，2，1，5；3，6，7为有序序列，4，2，1，5为无序序列 将4插入3，6，7中，得到3，4，6，7。 将2插入3，4，6，7中，得到2，3，4，6，7。 以此类推 动画演示 折半插入排序 查找有序子表时用折半查找。 希尔排序 选择一个增量序列 $ t_1，t_2，……，t_k $ ，其中 $ t_i &gt; t_j, t_k = 1 $； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 三、交换排序 冒泡排序（Bubble Sort） 冒泡排序可视化 两两比较相邻元素的值，如果它们为逆序，则交换他们，直到序列比较完，称为一趟冒泡。 每趟冒泡排序的结果是把序列中最大的元素放到了序列的最终位置。（也可以是每次把最小的放到最终位置，取决于算法的实现方式） 下一趟冒泡，待排序序列则减少一个元素。 动画演示 快速排序 快速排序算法可视化 核心思想：分治 选定Pivot中心轴 将大于Pivot的数字放在Pivot的右边 将小于Pivot的数字放在Pivot的左边 分别对左右子序列重复前三步操作 如：序列 19、97、09、17、01、08 数组下标 0 1 2 3 4 5 元素 19 97 09 17 01 08 我们每次选取最左侧的元素作为Pivot中心轴，所以选择19。现在需要把所有小于19的数字都放在19的左边，所有大于19的数字都放在19的右边。 设定两个下标，L：left下标，R：right下标。L不断右移，如果发现有大于19的数字，就把它放到右边去；R不断左移，如果发现有小于19的数字，就把它放到左边去。L、R会在某位置相遇，那么就把19放到重合的位置。 L、R交替运行。 第一步，查看L所在位置，为空。那么L停止，查看R所在位置，08小于19，应该放到19的左边，因此放到L所指位置。 数组下标 0 1 2 3 4 5 元素 null 97 09 17 01 08 L\R位置 L R 数组下标 0 1 2 3 4 5 元素 08 97 09 17 01 null L\R位置 L R 第二步，08放置完毕，此时R处为空。R不动，L右移，查看L所指位置，97大于19，因此将97放到的右边，也就是放到R所指位置。 数组下标 0 1 2 3 4 5 元素 08 null 09 17 01 97 L\R位置 L R 第三步，97防止完毕，此时L处为空。L不动，R左移，查看R所指位置，01小于19，因此将01放到19的左边，也就是L所指位置。 数组下标 0 1 2 3 4 5 元素 08 01 09 17 null 97 L\R位置 L R 第四步，01放置完毕，此时R处为空，R不动，L右移，查看L所指位置，09小于19，不需要进行交换，L继续右移。 数组下标 0 1 2 3 4 5 元素 08 01 09 17 null 97 L\R位置 L R 第五步，查看L所指位置，17比19小，不需要进行交换，L继续右移。 | 数组下标 | 0 | 1 | 2 | 3 | 4 | 5 | | -------- | ---- | ---- | ---- | ---- | ------- | ---- | | 元素 | 08 | 01 | 09 | 17 | null | 97 | | L\R位置 | | | | | L,R | | 第六步，此时LR相遇，因此将19放到L,R所指位置。 数组下标 0 1 2 3 4 5 元素 08 01 09 17 19 97 L\R位置 L,R 至此一趟排序完成，所有在19左边的数字都比19小，所有在19右边的数字都比19大。我们需要再对19左边与19右边两个子序列执行快速排序。 以此类推。 动画演示 四、选择排序 简单选择排序 简单选择排序可视化 每一趟选出待排序元素中的最大值与待排序元素的最后一位进行交换。 经过一趟，确定一个位置的值，待排序元素序列减少一位。 如图：待排序序列3，7，4，2，6，1为蓝色。 第一趟，选出待排序序列的最大值7与最后一个元素1进行交换。 第二趟，待排序序列变为3，1，4，2，6，最大元素已经在最后了，因此不用交换。 第三趟，待排序序列变为3，1，4，2，待排序序列最大元素4与最后一个元素2进行交换。 以此类推。 动画演示 堆排序 堆是一个完全二叉树，大根堆是双亲结点的值都要大于子结点的值。 同一层上，结点的大小顺序没有要求。比如 动画演示 五、归并排序与基数排序 归并排序 归并排序可视化 将两个或两个以上的有序表组合成一个新的有序表。 如 动画演示 基数排序 基数排序可视化 动画演示 六、各种排序的比较 时间复杂度辅助记忆： 需要两个for循环的：冒泡、直接插入、直接选择排序。 每次只关注一个元素，平均时间复杂度为 $ O(n^2) $ , 一遍是找元素 $ O(n) $ ，一遍是找位置 $ O(n) $ 。 采用二分思想的（加快了找位置的过程）：快排、归并、希尔、堆排序。 平均时间复杂度为 $ O(nlog_2 n) $ ，一遍找元素 $ O(n) $，一遍找位置 $ O(log_2 n) $。 归并排序由于分割子序列与初始序列的排序无关，因此最好、最坏、平均时间复杂度都是 $ O(nlog_2 n) $。 堆排序 初始化建堆的时间复杂度为 $ O(n) $ 排序重建堆的时间复杂度为 $ nlog(n) $ ： 循环 $ n -1 $ 次，每次都是从根节点往下循环查找，所以每一次时间是 $ log_2n $ ，总时间为 $ (n-1)log_2n = nlog_2n - log_2n $ 所以总的时间复杂度为$ O(n+nlog_2n)=O(nlog_2n) $。 空间复杂度辅助记忆： 快速排序需要一个小小的辅助栈，用于实现递归，平均情况需要 $ O(log_2 n) $ 。 归并排序需要借助较多的辅助空间进行元素的复制，大小为 $ O(n) $ 。 稳定性辅助记忆： 不稳定的排序算法：希尔排序、堆排序、快速排序、直接选择排序。 使用分治思想的排序算法中，归并排序最老实，一点点合并，其他算法都跨度很大。 直接（简单）选择排序算法总是与带排序序列最后一个交换，跨度也是很大。 确定最终位置： 冒泡排序、简单选择排序、堆排序在每次循环后都能产生当前的最大值或最小值。 快速排序一次循环就可以确定一个元素（基准元素）的最终位置。 七、外部排序 八、其他排序（超纲） 桶排序 计数排序]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工欲善其事，必先利其器]]></title>
    <url>%2Fliysuzy%2F2018%2F12%2F11%2F%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[软件 大多数软件为免费软件，收费软件我会加入💰图标 一、日常 OCR 天若OCR文字识别 OCR识别后可以自动翻译。 Mathpix Snipping Tool 可以准确地识别公式为latex语言。 截图 Snipaste 独有的贴图功能、占用内存空间少。 步骤记录器（Steps Recorder） Win10自带 录屏 XBOX Game bar Win10自带，我经常用。 **ApowerREC **💰 可选选项多。 文件搜索 Listary 💰 速度快，界面友好 下载 **Internet Download Manager ** 业界公认！ Firefox—Video DownloadHelper 插件 可以嗅探下载各种音视频 JIJIDOWN 可以下载BILIBILI的视频 硕鼠 可以下载部分网站的音视频 Proxyee-down 已经停止维护，过去的百度网盘下载神器。 上传 PicGo 图床神器 刻录 balenaEtcher U盘刻录软件 Rufus U盘引导盘制作工具 视频制作 ArcTime 简单、强大、高效的跨平台字幕制作软件。 鼠标手势 Shortcuts WGestures 社交 Franz5 聚合通信 二、编程 伪代码编写 Aurora 三、 音乐 识别 Riffstation 自动识别歌曲和弦（只能识别简单和弦） Celemony Melodyne Editor 可以识别音高，可以用于调音。 MIDI TiMidity 自带软音源的 MIDI 音乐播放器 打谱 Overture 💰 经典打谱软件 Sibelius 💰 拥有 Ribbon 界面的强大打谱软件，还可以用来学习（比如学习乐谱标记等）。 宿主 FL Studio 💰 Cubase 音源 四、网站 聚合类 Windows Apps That Amaze Us 狼牌工作网址导航 图标类 Iconfont]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 后端开发]]></title>
    <url>%2Fliysuzy%2F2018%2F11%2F28%2Fpython%20%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[环境配置 部分参考以下网站： https://cloud.tencent.com/developer/article/1005607 https://blog.csdn.net/ros_donggua/article/details/82800510 一、安装python虚拟环境 Ubuntu16.04以上都自带python，因此不需要安装python。 1. 安装virtualenv 1pip3 install virtualenv 2. 安装virtualenvwrapper 1pip3 install virtualenvwrapper 3. 配置环境变量 ① 创建虚拟环境管理目录 1mkdir ~/.virtualenvs ② 打开.bashrc 1sudo gedit ~/.bashrc ③ 在.bashrc的末尾增加下面内容 注：首先查看以下目录下有没有对应的文件或文件夹。 123export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source ~/.local/bin/virtualenvwrapper.sh UBUNTU低版本： 1source /usr/local/bin/virtualenvwrapper.sh 第一句为所有虚拟环境存储的目录 第二句当python2与python3共存时，需要指定运行virtualenvwrapper的python版本。 4. 虚拟环境的使用 创建虚拟环境 1mkvirtualenv env_name # env_name为你要创建的虚拟环境的名字，创建虚拟环境需要联网 创建指定python版本的虚拟环境 12mkvirtualenv -p /usr/bin/python3 env_name mkvirtualenv -p /usr/bin/python2 env_name 运行环境 12workon env_name workon + 两次tab键可以显示所有的虚拟环境 退出虚拟环境 1deactivate 删除虚拟环境 1rmvirtualenv env_name 查看所有的虚拟环境 1workon + 回车键 查看python、pip版本 12python --versionpip --version VSCode 配置虚拟环境 https://segmentfault.com/q/1010000011089735 二、安装配置Django环境 1. 进入虚拟环境 1workon test3 2. pip3安装Django 12pip3 install Django或 pip install Django(因为在python3虚拟环境中，只有python3) 很慢。。。 apt-get 相关操作 1234567sudo apt-get update:更新安装列表sudo apt-get upgrade:升级软件sudo apt-get install software_name :安装软件sudo apt-get --purge remove software_name :卸载软件及其配置sudo apt-get autoremove software_name:卸载软件及其依赖的安装包dpkg --list:罗列已安装软件 3. 验证是否安装成功以及查看是否符合所需的版本 1234$ python&gt;&gt;&gt; import django&gt;&gt;&gt; print(django.get_version())2.1.3 或者 1ubuntu 终端下：python -m django --version 三、创建VUE项目 1. node.js环境搭建 ① node.js安装 ② 检测node.js, npm是否安装成功 ③ nrm安装 nrm的作用 实际上提供了最常用的npm包镜像地址(类似于python包的豆瓣源,清华源),能够快速切换下载安装包的服务器地址. 1.运行npm i nrm -g 全局安装nrm包 2.使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 3.使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意：npm 无法全局安装的问题解决方案： 查看全局路径 1npm config get prefix 修改usr/local的权限。使用sudo有一个风险是安装包可能会运行自己的一些脚本，使sudo操作变的不可控，不安全。 可以通过将/usr/local的own从root转为登陆用户来解决这个问题。 12sudo chown -R $USER /usr/local或 sudo chown -R $USER /usr/local/nodejs 2. VUE环境搭建 vue-cli 安装 vue-cli是快速创建一个vue项目的脚手架,介绍请自行谷歌 运行npm install -g vue-cli 全局安装vue-cli 3. 搭建VUE项目 1. 创建VUE项目 运行vue init webpack fronted 生成fronted项目名的vue项目文件,默认回车即可(eslink是es6检测es6语法格式的,test是测试的 ,这两个如果不用的话,可以选no),默认会安装 vue-router。 项目中各个文件的含义，该博客简单介绍了vue-cli(博客是1年前的,不过入个门还是可以的) 2. 安装依赖 cd fronted 进入vue项目目录,运行npm install 安装依赖,会在项目目录下生成node_module文件 vue开发看这篇就够了 3. 一些常用指令 123npm run dev # 在开发配置下运行vue项目npm run start # 同上npm run build # 将vue项目 通过webpack打包 生成原生js,css文件,以及index.html 在会生成在dist文件 npm的使用命令大全 4. 在vue中使用scss 使用vue-cli搭建项目有内置的webpack方案，但是没有使用scss。vue提供了初始化的webpack模板，其中使用了vue-loader。vue-loader默认只支持sass,要是想要使用scss，必须安装node-sass和sass-loader，并修改相关webpack配置。具体操作如下: ① 安装node-sass 和 sass-loadr 12npm install node-sass --save-devnpm install sass-loader --save-dev note :记得要在vue项目目录下运行该指令, 这样才会在该项目中安装 ② 修改相关webpack配置 打开webpack.base.config.js, 在module里的rules中加上： 1234&#123; test: /\.scss$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;] &#125;, ③ 如果要在vue文件中的style使用scss,则在 style处声明： 1&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot;&gt;&lt;/style&gt; 四、创建Django项目(2.1版本，非2.1版本有差异) 1. 创建项目 1django-admin startproject testproject 2. 查看目录 安装树状目录结构工具 1sudo apt-get install tree 3. 在子文件夹testproject下建立视图文件views.py 123456789# -*- coding: utf-8 -*- from django.http import JsonResponsefrom django.views.decorators.csrf import csrf_exempt @csrf_exemptdef test_api(request): return JsonResponse(&#123;&quot;result&quot;: 0, &quot;msg&quot;: &quot;执行成功&quot;&#125;) 4. 修改子文件夹testproject下的urls.py 12345678from django.contrib import adminfrom django.urls import pathfrom testproject import viewsurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;test_api/&apos;, views.test_api, name=&apos;test_api&apos;),] 5. 启动Django，在项目根目录运行 1python manage.py runserver 输出 1234567891011Performing system checks...System check identified no issues (0 silenced).You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.八月 01, 2018 - 15:50:53Django version 2.0, using settings &apos;mysite.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 表示启动成功，在浏览器访问127.0.0.1:8000/test_api,接口请求成功 至此，后端接口已经基本搭建完毕，下一步还需要解决跨域问题。 6. 解决跨域问题 开发调试时,实际上是开两个server,一个是8000端口的django server,一个是8080端口的node server 有两种解决方法,一种是在Vue.js层上做转发(proxy Table).另一种是在django层注入header.这里介绍第二种方法: ① 安装 1pip install django-cors-headers ② 配置settings,py 123456789101112131415#settings.py# 中间件那里添加 注意 中间件的加载顺序别弄错MIDDLEWARE = [ &apos;django.middleware.security.SecurityMiddleware&apos;, &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, **&apos;corsheaders.middleware.CorsMiddleware&apos;,** &apos;django.middleware.common.CommonMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, &apos;django.contrib.messages.middleware.MessageMiddleware&apos;, &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,]# 增加一行CORS_ORIGIN_ALLOW_ALL = True 另一种做法，可以都试一下 1234567891011121314151617181920212223242526272829303132333435363738394041INSTALLED_APPS = [ ... &apos;corsheaders&apos;， ... ] MIDDLEWARE_CLASSES = ( ... &apos;corsheaders.middleware.CorsMiddleware&apos;, &apos;django.middleware.common.CommonMiddleware&apos;, # 注意顺序 ...)#跨域增加忽略CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = ( &apos;*&apos;) CORS_ALLOW_METHODS = ( &apos;DELETE&apos;, &apos;GET&apos;, &apos;OPTIONS&apos;, &apos;PATCH&apos;, &apos;POST&apos;, &apos;PUT&apos;, &apos;VIEW&apos;,) CORS_ALLOW_HEADERS = ( &apos;XMLHttpRequest&apos;, &apos;X_FILENAME&apos;, &apos;accept-encoding&apos;, &apos;authorization&apos;, &apos;content-type&apos;, &apos;dnt&apos;, &apos;origin&apos;, &apos;user-agent&apos;, &apos;x-csrftoken&apos;, &apos;x-requested-with&apos;,) 到这里就可以开始做django项目的开发,以及和vue项目之间的联调了. 五、整合项目 1. webpack 打包 vue项目 vue项目目录下 ,运行npm run build 生成webpack打包后的dist文件夹,文件夹下有static 文件夹和一个index.html 2. 配置django 模板搜索路径和静态文件搜索路径 在django项目中新建一个fronted文件夹,并把dist文件复制到里面 1234567891011121314151617181920212223242526#settings.py#模板搜索路径配置TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, # &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], **&apos;DIRS&apos;: [&apos;frontend/dist&apos;],** &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,]# 配置静态文件搜索路径STATICFILES_DIRS = [ os.path.join(BASE_DIR, &quot;frontend/dist/static&quot;),]# 把跨域开启CORS_ORIGIN_ALLOW_ALL = False 经过整合,django项目已经基本上完成了,也可以使用runserver 运行起来了.但是生产环境不可能用runserver 项目上线]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE SSM]]></title>
    <url>%2Fliysuzy%2F2018%2F11%2F28%2FVUE%20SSM%2F</url>
    <content type="text"><![CDATA[VUE 配置 一、创建 VUE 项目 1. node.js 环境搭建 ① node.js 安装 ② 检测 node.js, npm 是否安装成功 * ③ nrm 安装 * ④ cnpm 安装 nrm 的作用 实际上提供了最常用的 npm 包镜像地址(类似于 python 包的豆瓣源,清华源),能够快速切换下载安装包的服务器地址. 1.运行 npm i nrm -g 全局安装 nrm 包 2.使用 nrm ls 查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 3.使用 nrm use npm 或 nrm use taobao 切换不同的镜像源地址； cnpm 执行命令：npm install cnpm -g --registry=https://registry.npm.taobao.org cnpm -v 查看 cnpm 版本号 注意：npm 无法全局安装的问题解决方案： 查看全局路径 1npm config get prefix 修改 usr/local 的权限。使用 sudo 有一个风险是安装包可能会运行自己的一些脚本，使 sudo 操作变的不可控，不安全。 可以通过将/usr/local 的 own 从 root 转为登陆用户来解决这个问题。 12sudo chown -R $USER /usr/local或 sudo chown -R $USER /usr/local/nodejs 2. VUE 环境搭建 vue-cli 安装 vue-cli 是快速创建一个 vue 项目的脚手架,介绍请自行谷歌 运行npm install -g vue-cli 全局安装 vue-cli 3. 搭建 VUE 项目 (1) 创建 VUE 项目 运行 vue init webpack frontend 生成 frontend 项目名的 VUE 项目文件,默认回车即可(eslink 是 es6 检测 es6 语法格式的,test 是测试的 ,这两个如果不用的话,可以选 no),默认会安装 vue-router。 项目中各个文件的含义，该博客简单介绍了 vue-cli(博客是 1 年前的,不过入个门还是可以的) (2) 安装依赖 cd frontend 进入 VUE 项目目录,运行npm install 安装依赖,会在项目目录下生成node_module文件 vue 开发看这篇就够了 (3) 一些常用指令 123npm run dev # 在开发配置下运行vue项目npm run start # 同上npm run build # 将vue项目 通过webpack打包 生成原生js,css文件,以及index.html 在会生成在dist文件 npm 的使用命令大全 4. 配置 VUE 项目 (1) 在 VUE 中使用 scss 使用 vue-cli 搭建项目有内置的 webpack 方案，但是没有使用 scss。vue 提供了初始化的 webpack 模板，其中使用了 vue-loader。vue-loader 默认只支持 sass,要是想要使用 scss，必须安装 node-sass 和 sass-loader，并修改相关 webpack 配置。具体操作如下: ① 安装 node-sass 和 sass-loadr 12npm install node-sass --save-devnpm install sass-loader --save-dev note :记得要在 vue 项目目录下运行该指令, 这样才会在该项目中安装 ② 修改相关 webpack 配置 打开 webpack.base.config.js , 在 module 里的 rules 中加上： 1234&#123; test: /\.scss$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;] &#125;, ③ 如果要在 vue 文件中的 style 使用 scss,则在 style 处声明： 1&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot;&gt;&lt;/style&gt; (2) 在 VUE 中使用 axios 参考 https://blog.csdn.net/qq_22046267/article/details/81322099 ① 安装 axios 1npm install --save axios ② 在入口 main.js 中导入 axios 并将 axios 写入 vue 的原型。 123456import axios from &apos;axios&apos;import Qs from &apos;qs&apos;//QS是axios库中带的，不需要我们再npm安装一个Vue.prototype.axios = axios;Vue.prototype.qs = Qs; axios 并不像 ajax 或者 vue-resource 那样，它默认 post 是以 Request Payload 这种形式来传输的 Qs 这个库是帮助我们解决这个问题的 反向代理解决跨域请求问题 参考 https://blog.csdn.net/feifanzhuli/article/details/77990661 ③ 使用 axios 详见 axios 官方文档或 VUE 官方文档 axios 部分。 https://cn.vuejs.org/v2/cookbook/using-axios-to-consume-apis.html 123456// 使用axios的一个小例子handleLogin() &#123; this.axios .get(&quot;/HelpForum/api/test&quot;) .then(response =&gt; (this.info = response)); &#125; (3) 使用基于VUE的UI 推荐： element UI: http://element-cn.eleme.io/#/zh-CN iview UI: https://www.iviewui.com/ 我的项目使用的是 layui ，但是 layui 的自带 js 有时会与 VUE 的有冲突，要注意。比如渲染一个 DOM 的时间先后问题。 5. VUE与SSM项目的整合 将 VUE 与 SSM 整合，需要将 VUE 项目 build 后的 dist 文件夹放到 SSM 目的指定位置，仍然需要做一下配置，否则会出现无法访问 VUE 项目的资源文件的问题。 参考 https://blog.csdn.net/harmsworth2016/article/details/80993426 跨域解释，参考 https://www.cnblogs.com/chenshishuo/p/4919224.html 解释几个名词： 同源策略： 请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同. 跨域 浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了. 注：这种方式直接将 VUE 项目置于 SSM 项目中，使用同一个端口，不存在跨域问题。 如果 VUE 跑在一个端口，SSM 的 Tomcat 在另一个端口，那么就会出现跨域问题，可以用上面的方法进行解决，如果没有效果，可以尝试用 nginx 做反向代理 ① 修改 config 目录下 index.js 搜索 assetsPublicPath，将其由’/‘改为’./’，如图 ② 覆盖此加载程序的publicPath设置， 修改 build 目录下 utils.js 如图修改： ③ 打包 实质是执行package.json中定义的build.js文件 1npm run build Spring Boot 配置 一、JAVA安装 环境变量： 二、Maven安装 参考： http://www.cnblogs.com/wkrbky/p/6350334.html?utm_source=itdadao&amp;utm_medium=referral Maven官网 下载下图文件，将它解压到你要安装 Maven 的文件夹。 添加环境变量 M2_HOME MAVEN_HOME 添加 M2_HOME 和 MAVEN_HOME 环境变量到 Windows 环境变量，并将其指向你的 Maven 文件夹。 M2_HOME 或 MAVEN_HOME Maven 说只是添加 M2_HOME , 但一些项目仍引用 Maven 的文件夹MAVEN_HOME, 因此，为了安全也把它添加进去。 添加到 PATH 更新 PATH 变量，添加 Maven bin 文件夹到 PATH 的最后，如： %M2_HOME%\bin, 这样就可以在命令中的任何目录下运行 Maven 命令了。 验证是否成功添加环境变量 如果你看到类似消息，说明 Apache Maven 在 Windows 上已安装成功。 三、配置 Maven 本地仓库 创建一个仓库文件夹 maven-repository ，该目录用作maven的本地库。 打开 Maven 安装目录下 \conf\settings.xml 文件，修改下面代码。localRepository 节点默认是被注释掉的，需要把它移到注释之外，然后将 localRepository 节点的值改为我们设定的文件夹。 localRepository 节点用于配置本地仓库。 本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\Users\用户名.m2。当我们从 maven 中获取 jar 包的时候，maven 首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。 此外，我们在 maven 项目中运行 mvn install，项目将会自动打包并安装到本地仓库中。 运行一下DOS命令 mvn help:system 如果前面的配置成功，那么 maven-repository 文件夹会出现一些文件。 四、IntelliJ 配置 Maven 点击 Settings 找到 Build,Execution,Deployment–&gt;Builds Tools–&gt;Maven 修改标红处为上面配置的路径。 打开maven下的importing页面，勾选右面Sources和Documentation即可。 五、创建SpringBoot + Mybatis 工程 （一）创建项目 点击 File ，创建新工程，选择Spring Initializr。 填写相关信息 选择需要加入的依赖 下一步，Finish即可 （二）相关配置及基本目录结构创建 初始项目结构 删掉application.properties, 在相同的位置创建application.yml 在application.yml中添加server，datasource的配置。 server: 端口号 datasource: 包括用户名、密码、数据库访问地址 1234567891011server: port: 9000spring: datasource: username: root password: 123456 url: jdbc:mysql://127.0.0.1:3306/vblog?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8mybatis: config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml 创建SpringBoot目录结构 关于 Controller Service层 参考 https://segmentfault.com/q/1010000018560036?utm_source=tag-newest 假设我有一个注册接口，controller写了一个@RequestMapping(&quot;/register&quot;)之后，有这些东西: ①验证验证码和重复密码是否正确 ②到数据库查找用户名和邮箱是不是已经存在 ③上面验证都没问题，向数据库插入一条数据 ④向用户邮箱发送一封激活邮件 ⑤返回注册成功给用户 业务逻辑要在service中实现，而control负责把service层返回的数据加工转换为方便jsp或者其他模板容易渲染的格式，传递给view层，或者按照前端要求的格式转换为json传递给前端（ajax方式）。 除了5要在controller写之外，其他都应该写在service层。当然，狭隘的业务逻辑只是3和4。1/2属于数据验证，数据验证和业务逻辑有一定关系，如果按照狭义的业务逻辑理解，1/2也可以放在controller中。 向mybatis-config.xml中添加内容 当前项目只用到了一个配置： 开启驼峰命名规则自动转换 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--开启驼峰命名规则自动转换--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; （三*[可忽略]）添加自动化工具 修改pom.xml，添加相关依赖 位置： 123456789101112131415161718192021222324252627282930313233343536&lt;!-- Mybatis 自动化工具 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;mybatis generator&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 覆盖生成的文件（大型项目不允许开启，避免更改他人文件） --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!--&lt;overwrite&gt;false&lt;/overwrite&gt;--&gt; &lt;configurationFile&gt; src/main/resources/mybatis/mybatis-generator.xml &lt;/configurationFile&gt; &lt;/configuration&gt;&lt;/plugin&gt; 创建mybatis-generator.xml文件，配置generator 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 去掉生成的注释 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;!--前面几个属性设置时区，最后一个属性不添加，生成的dao类只有插入操作--&gt; &lt;!-- nullCatalogMeansCurrent=true 意思为生成所有方法，包括insert update delete 简单的select --&gt; &lt;!-- com.mysql.cj.jdbc.Driver 避免报过时的错误 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/vblog?useUnicode=true&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=UTC&amp;amp;nullCatalogMeansCurrent=true&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--生成实体类存放位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.example.vblog.bean&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mybatis/mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成Mapper Interface存放位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.example.vblog.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名--&gt; &lt;table tableName=&quot;user_info&quot; domainObjectName=&quot;UserInfoBean&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置运行generator 添加maven工具 运行generator 点击绿色三角运行 自动生成后的项目结构 生成命令行结果 （四）写一个小Demo测试是否可以正常运行]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>VUE</tag>
        <tag>前端</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网开发技术]]></title>
    <url>%2Fliysuzy%2F2018%2F11%2F11%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Session 2 Task 1: System call fork(), exec() and process signalling I. Background Processing 123456789101112131415161718192021222324// 该程序模拟了一个shell程序#include &lt;stdio.h&gt;int main( void ) &#123; char *argv[3] = &#123;&quot;Command-line&quot;, &quot;.&quot;, NULL&#125;; int pid = fork(); // 创建子进程的原因：如果在父进程中调用execvp的话，我们做的这个shell程序就只能调用一条命令了。 if ( pid == 0 ) &#123; execvp( &quot;find&quot;, argv ); &#125; wait( 2 ); // wait函数主要做两件事，首先wait暂停调用它的进程直到子进程结束，然后wait通过status取得子进程结束时传给exit的值。wait返回结束进程的PID，如果进程没有子进程或没有得到终止状态值，则返回-1。 //其实在fork之后，父子进程是并行执行的，而我们想要的效果是父进程先等等，等子进程结束之后再继续执行。wait()函数可以做到这一点。 printf( &quot;Finished executing the parent process\n&quot; &quot; - the child won&apos;t get here--you will only see this once\n&quot; ); return 0;&#125;// 这样通过不断地创建子进程，用想要执行的程序代替子进程并且让父进程等待，最后执行完毕，回到父进程，我们也就模拟了一个shell程序。 fork() fork.c() fork（）返回父进程中子进程的进程标识符（pid） fork（）在子节点中返回0 每个进程都可以使用getpid（）查询自己的进程标识符。 exec() exec.c() 运行结果 exec() 系列说明 123456int execl（const char * path，const char * arg，...）;int execlp（const char * file，const char * arg，...）;int execle（const char * path，const char * arg，...，char * const envp []）;int execv（const char * path，char * const argv []）;int execvp（const char * file，char * const argv []）;int execve（const char * file，char * const argv []，char * const envp []）; 每个系统调用都是单词exec，后跟l 或 v，在此之后后可能后跟e或p。 前三个具有execl形式并接受可变数量的参数。要使用此功能，必须加载&lt;stdarg.h&gt;头文件。请参阅示例stdarg.c。 后三者的形式为execv，在这种情况下，参数是使用指向字符串的指针数组传递的，其中最后一个条目为NULL。例如，可能有 char *argv[] = {&quot;Hello &quot;, &quot;world!&quot;, NULL}; 如果名称以l或v结尾，则必须完整地给出程序名称。 如果该名称是由lp或vp结尾，它将搜索使用当前环境变量的文件路径，通常包括/bin/, /usr/bin/，等等。 最后，如果名称由le或ve结尾，则可以包含指示环境变量的字符串数组，每个形式为&quot;ENVVAR=value&quot;且数组为空终止。例如， char *envp[] = {&quot;USER=dwharder&quot;, &quot;HOME=/home/dwharder&quot;, NULL}; II. System call dup and dup2 dup() &amp; dup2() dup() 文件描述符在内核中的形态 个进程在此存在期间，会有一些文件被打开，从而会返回一些文件描述符，从shell中运行一个进程，默认会有3个文件描述符存在(0、1、2)。 0 与进程的标准输入相关联 1 与进程的标准输出相关联 2 与进程的标准错误输出相关联 一个进程当前有哪些打开的文件描述符可以通过/proc/进程ID/fd目录查看。 12#include &lt;unistd.h&gt;int dup(int oldfd); 功能：复制文件描述符 说明： 复制一个和file_desc指向同一个文件的文件描述符, 并且新的文件描述符总是取最小的可用值。（标准输入描述符总是0，并且dup函数调用总是取最小可用的数字，如果关闭0,再调用dup函数，新的文件描述符就是0了。） 返回值：调用成功返回新的文件描述符，调用失败返回-1. e.g. dup() 12345678910111213141516171819202122232425262728#define _POSIX_SOURCE#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#undef _POSIX_SOURCE#include &lt;stdio.h&gt;void print_inode(int fd) &#123; struct stat info; if (fstat(fd, &amp;info) != 0) fprintf(stderr,&quot;fstat() error for fd %d: %s\n&quot;,fd,strerror(errno)); else printf(&quot;The inode of fd %d is %d\n&quot;, fd, (int) info.st_ino);&#125;main() &#123; int fd; if ((fd = dup(0)) &lt; 0) perror(&quot;&amp;dupf error&quot;); else &#123; print_inode(0); print_inode(fd); puts(&quot;The file descriptors are different but&quot;); puts(&quot;they point to the same file.&quot;); close(fd); &#125;&#125; dup() 12#include &lt;unistd.h&gt;int dup2(int fildes, int fildes2); 功能：复制文件描述符，删除旧的文件描述符 功能说明：dup2是一个类似于dup的系统调用，它复制一个文件描述符，使它们成为别名，然后删除旧的文件描述符。这在尝试重定向输出时变得非常有用，因为它自动处理关闭新文件描述符，在一个命令中执行重定向。例如，如果要将标准输出重定向到文件，则只需调用dup2，将文件的打开文件描述符作为第一个命令，将1（标准输出）作为第二个命令。 参数说明： int fildes: 源文件描述符。在调用dup2之后，这仍然是打开的。 int fildes2: 目标文件描述符。此调用返回后，此文件描述符将指向与filedes相同的文件。 返回值：dup2成功后返回第二个参数（fildes2）的值。负返回值表示发生错误。 e.g. dup2() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Scott Kuhl//// This program does not check the return code of close(), dup2(),// execlp(), fork(), and waitpid(). A good program would add those// additional checks!#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define READ_END 0#define WRITE_END 1int main (void)&#123; int fd[2]; pipe(fd); // pipe() could return an error. I&apos;m not checking it. int child1 = fork(); if(child1 == 0) /* we are child 1 */ &#123; // we will be writing to the pipe, no need to read: close(fd[READ_END]); // When we write to stdout for this process, actually write to // the write end of the pipe. I.e., make the stdout file // descriptor be an &quot;alias&quot; for the write end of the pipe. // // To do this, dup2() will actually close stdout and then // create a new file descriptor with the same number as // stdout---and ensure that it behaves exactly the same as the // write end of the pipe. dup2(fd[WRITE_END], STDOUT_FILENO); // I&apos;m not checking return value for error! execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, NULL); // execlp() does not return (except when an error occurred). printf(&quot;execlp() failed.\n&quot;); exit(EXIT_FAILURE); // exit child process if exec fails. &#125; /* Only parent gets here. */ pid_t child2 = fork(); if(child2 == 0) /* we are child 2 */ &#123; // we will be reading from the pipe, no need to write: close(fd[WRITE_END]); // whenever we read from stdin, actually read from the pipe. dup2(fd[READ_END], STDIN_FILENO); // change every &apos;s&apos; into an &apos;X&apos; execlp(&quot;tr&quot;, &quot;tr&quot;,&quot;s&quot;, &quot;X&quot;,NULL); // execlp() does not return (except when an error occurred) printf(&quot;execlp() failed.\n&quot;); exit(EXIT_FAILURE); // exit child process if exec fails. &#125; /* Only parent gets here. If parent doesn&apos;t close the WRITE_END of * the pipe, then child2 might not exit because the parent could * still write data into the pipe that child2 is reading from. */ close(fd[READ_END]); close(fd[WRITE_END]); /* We could call wait() twice here instead of using waitpid() on * child2. * * The &apos;tr&apos; program is written so * that it will read bytes from stdin until there are no more * bytes to read. Since it is actually reading from the pipe, * there are no more bytes to read from the pipe when the write * end of the pipe is closed. The write end will be closed when * child1 exits---because the OS will ensure that stdin, stdout, * stderr, and all other file descriptors are closed when every * program exits. * * Therefore, child2 can only exit when child1 is finished. If * both child1 and child2 ran &quot;ls&quot;, then this assumption wouldn&apos;t * be true because the second &quot;ls&quot; command will exit after * printing to stdout---it doesn&apos;t read any thing from stdin, and * it doesn&apos;t wait for stdin to be be closed by the writer before * exiting. */ int status; waitpid(child2, &amp;status, 0);&#125; 3. Death of Children 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* limit.c */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;int delay;void childHandler ()&#123; int childPid, ChildStatus; childPid = wait (&amp;ChildStatus); printf (&quot;Child %d terminated within %d seconds\n&quot;, childPid, delay); exit(0);&#125;main (argc, argv)int argc;char* argv[];&#123; int pid; signal (SIGCHLD, childHandler); pid = fork (); if (pid ==0) /* child */ &#123; execvp (argv[2], &amp;argv[2]); perror (&quot;limit&quot;); &#125; else &#123; sscanf (argv[1], &quot;%d&quot;, &amp;delay); sleep (delay); printf (&quot;Child %d exceeded limit and is being killed\n&quot;, pid); kill (pid, SIGINT); &#125;&#125;/* Compile and run the program:% cc limit.c -o limit% ./limit 5 ls (See output !)1% ./limit 4 sleep 100 (See output !)*/ 下面内容转自https://www.cnblogs.com/sky-heaven/p/8074273.html (md partial supported) i 什么是僵尸进程？ 首先内核会释放终止进程(调用了exit系统调用)所使用的所有存储区，关闭所有打开的文件等，但内核为每一个终止子进程保存了一定量的信息。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。 而僵尸进程就是指：一个进程执行了exit系统调用退出，而其父进程并没有为它收尸(调用wait或waitpid来获得它的结束状态)的进程。 任何一个子进程(init除外)在exit后并非马上就消失，而是留下一个称外僵尸进程的数据结构，等待父进程处理。这是每个子进程都必需经历的阶段。另外子进程退出的时候会向其父进程发送一个SIGCHLD信号。 ii 僵尸进程的目的？ 设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。 iii 如何避免僵尸进程？ 通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。 父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。 如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出。 通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。 第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。 iiii 僵尸进程处理办法 wait()函数 1234#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;pid_t wait(int *status); 进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。 参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样： pid = wait(NULL); 如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。 wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。 返回的是子进程的PID，它通常是结束的子进程 状态信息允许父进程判定子进程的退出状态，即从子进程的main函数返回的值或子进程中exit语句的退出码。 如果status不是一个空指针，状态信息将被写入它指向的位置 可以上述的一些宏判断子进程的退出情况： waitpid()函数 略 4. Suspending and resuming processes (暂停和恢复进程) SIGSTOP和SIGCONT信号分别暂停和恢复进程。 Unix shell使用它们来实现内置命令，如stop，fg和bg。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* pulse.c */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;main ()&#123; int pid1; int pid2; pid1 = fork (); if (pid1 == 0) /* the first child */ &#123; while (1) &#123; printf (&quot;pid1 is alive\n&quot;); sleep (1); &#125; &#125;pid2 = fork (); /* second child */if (pid2 ==0) &#123; while (1) &#123; printf (&quot;pid2 is alive\n&quot;); sleep (1); &#125; &#125;sleep (3);kill (pid1, SIGSTOP); /* suspend first child */sleep (3);kill (pid1, SIGCONT); /* resume first child */sleep (3);kill (pid1, SIGINT); /* killl first child */kill (pid2, SIGINT); /* killl second child */&#125;/* To compile and run the program:% cc pulse.c -o pulse% ./pulse(See output!)*/ Task 2: fork(), pipe() and TCP daytime client in C 具体实践]]></content>
      <tags>
        <tag>互联网开发技术</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法制导翻译——S-属性定义的自底向上计算 Python实现]]></title>
    <url>%2Fliysuzy%2F2018%2F11%2F10%2F%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%20%20python%2F</url>
    <content type="text"><![CDATA[一、什么是语法制导翻译 为了提高编译程序的可移植性，一般将编译程序划分为前端和后端。 前端通常包括词法分析、语法分析、语义分析、中间代码生成、符号表的建立，以及与机器无关的中间代码优化等，它们的实现一般不依赖于具体的目标机器。 后端通常包括与机器有关的代码优化、目标代码的生成、相关的错误处理以及符号表的访问等。 语义分析器的主要任务是检查各个语法结构的静态语义，即验证语法正确的程序结构是否真正有意义，也称为静态语义分析或静态检查 静态检查比较简单，可以和其他工作结合。 将静态检查和中间代码生成结合到语法分析中进行的技术称为语法制导翻译 (syntax-directed translation)。 二、语法制导翻译的基本知识 大量文字预警 I. 基本思想 在进行语法分析的同时，完成相应的语义处理。 一旦语法分析器识别出一个语法结构（例如 $ E \rightarrow E+T $ ）就要立即对其进行翻译。 翻译是根据语言的语义进行的，并通过调用事先为该语法结构编写的语义子程序来实现。 对文法中的每个产生式附加一个/多个语义动作(或语义子程序) 在语法分析的过程中，每当需要使用一个产生式进行推导或归约时，语法分析程序除执行相应的语法分析动作外，还要执行相应的语义动作(或调用相应的语义子程序)。 II. 语义子程序的功能 指明相应产生式中各个文法符号的具体含义，并规定了使用该产生式进行分析时所应采取的语义动作。 语义信息是通过文法符号来携带和传递的。 III. 属性 一个文法符号X所携带的语义信息称为X的语义属性，简称为属性 它是根据翻译的需要设置的，主要用于描述语法结构的语义。 文法符号的属性的计算规则称为语义规则。 一个变量的属性有类型、值和存储地址等。 属性值的计算和产生式相关联，随着语法分析的进行，执行属性值的计算，完成语义分析和翻译的任务。 语法结构具有规定的语义，如： $ E \rightarrow E_1 + E_2 $ $ E.val := E_1.val + E_2.val $ IV. 属性值的计算及翻译工作同产生式相关联————语法制导定义法 对应每一个产生式编写一个语义子程序，当一个产生式获得匹配时，就调用相应的语义子程序来实现语义检查与翻译。 适宜在完成归约的时候进行。 V. 语法制导定义 综合属性：节点的属性值是通过分析树中该节点或其子节点的属性值计算出来的 继承属性：节点的属性值是由该节点、该节点的兄弟节点或父节点的属性值计算出来的 固有属性：通过词法分析直接得到的属性 VI. S-属性定义 只含综合属性的语法制导定义称为S-属性定义 通常在自底向上的分析方法计算属性值 可以按照自下而上的顺序来计算分析树中节点的属性 在建立每一个结点处使用语义规则来计算综合属性值，即在用哪个产生式进行归约后，就执行那个产生式的S-属性定义计算属性的值 三、S-属性定义的自底向上计算实现 I. 思想 将每个语义规则放到相应产生式的末尾即可得到一个翻译模式（后缀式语法制导翻译模式） 对产生式归约时执行语义动作 II. 条件 在LR分析过程中实现 III. 实现 产生式 语义规则 $ S \rightarrow E $ $ print(E.val) $ $ E \rightarrow E_1 + T $ $ E.val := E_1.val + T.val $ $ E \rightarrow T $ $ E.val := T.val $ $ T \rightarrow T_1 * F $ $ T.val := T_1.val * F.val $ $ T \rightarrow F $ $ T.val := F.val $ $ F \rightarrow (E) $ $ F.val := E.val $ $ F \rightarrow digit $ $ F.val := digit.lexval $ lexval: 固有属性，通过词法分析直接得到的属性。 val: 综合属性，值为该节点或其子节点的属性值计算出来的 需要实现表达式 $ 61 + 7 × 8 + 3 × ( 2 + 1111 ) $ 的值的计算 1. 语义规则存储 需要将语义规则存入文法中，由于在语法分析器中，已经有固定的函数来处理文法了，为了避免修改原有的函数，我将语义规则存入了另一个文件。 语义规则简化为： $ \lbrace S=E, E=E+T, E=T, T=T*F, T=F, F=E, F=g \rbrace $ 2. 读取语义规则，生成输入流与数值流的对应关系 在我实现的语法分析器中，输入流是这种形式的，如果计算 $ 61 + 7 × 8 + 3 × ( 2 + 1111 ) $ ，（字符）输入流 $ g + g × g + g × ( g × g ) $ , $ NUM $ 被映射为符号 $ g $ ,用于对应文法。 由于语法制导翻译是在语义分析中实现的，因此我想可以增加一个输入流，为数值流，与字符输入流相对应。 数值流规则：数字的值为该数字，其余字符的值均为’_’。 3. 创建一个栈————分析栈（值栈） 该栈与符号栈相对应。对应位置即为符号的值。 归约时分析栈同符号栈归约方式相同，只是分析栈需要计算归约出字符的值。 4. 分析栈的归约 123456789101112131415161718def calculateRecuctionVal(reductionVals, reductionIndex): # reductionVals: 要归约的所有符号值，reductionIndex: 归约的文法下标 valsDict = &#123;&#125; i = -1 while grammarOriginalListsWithArrow[reductionIndex][i] != '&gt;': if reductionVals[i] != '_': valsDict[grammarOriginalListsWithArrow[reductionIndex][i]] = reductionVals[i] i = i-1 resultVal = 0 if '*' in rule[reductionIndex]: charIndex = rule[reductionIndex].index('*') resultVal = int(valsDict[rule[reductionIndex][charIndex-1]]) * int(valsDict[rule[reductionIndex][charIndex+1]]) elif '+' in rule[reductionIndex]: charIndex = rule[reductionIndex].index('+') resultVal = int(valsDict[rule[reductionIndex][charIndex-1]]) + int(valsDict[rule[reductionIndex][charIndex+1]]) else: resultVal = int(valsDict[rule[reductionIndex][-1]]) print(valsDict) return resultVal 针对该文法，我写了计算该文法归约字符值的函数。 函数思想 创建一个映射，为文法中产生式中的字符与值的映射。比如我们要计算 $ 11+627 $ 使用 $ E \rightarrow E + T $ , 建立映射： $ \lbrace E:11, T:627 \rbrace $ 读取文法对应的语义规则，进行相应计算。 $ E \rightarrow E + T $ 的语义规则是 $ E = E + T $ ，即把 $ E $ 的值与 $ T $ 值相加，赋值给 $ E $ . 返回 $ E $ 的值 四、 源码 https://git.dev.tencent.com/liysuzy/Compilers.git 如有问题请与我联系，1121899707@msn.cn]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Python</tag>
        <tag>语法分析</tag>
        <tag>语义分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLR语法分析器 python实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F31%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%20%20python%2F</url>
    <content type="text"><![CDATA[一、语法分析器做什么 语法分析是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。 一个语法分析器从词法分析器获得一个词素序列，并验证这个序列是否可以由源语言的文法生成。语法分析器会构造一棵语法分析树，并把它传递给编译器的其他部分进一步处理，在构建语法分析树的过程中，就验证了这个词素序列是否符合源语言的文法。 二、自底向上的语法分析器的实现 I. 推导方式 输入：文法 $ G=(V,T,P,S) $ 的拓广文法 $ G’ $ 输出： $ G’ $ 的 $ LR(0) $ 分析表。即 $ action $ 和 $ goto $ 表 步骤： ① 构造 $ I_0 $ 。 $ I_0 = CLOSURE( \lbrace S’ \rightarrow .S \rbrace ) $ ② 通过 $ GO(I_i, X) $ 函数求出 $ LR(0) $ 的项目集规范族 $ C= \lbrace I_0,I_1,…,I_n \rbrace $ ③ 遍历项目及规范族 $ C $ ， $ I_0 $ 对应初始状态 $ 0 $， $ I_i $ 对应状态 $ i $ (1) 若项目 $ A→α·aβ $ 属于 $ I_k $ 且转换函数 $ GO(I_k,a)= I_j $ ，当 $ a $ 为终结符时，则置 $ ACTION[k,a] $ 为 $ S_j $ 。 (2) 若项目 $ A→α· $ 属于 $ I_k $ ，则对任何终结符 $ a $ 和’#'置 $ ACTION[k,a] $ 和 $ ACTION $ [k,#]为 $ r_j $ ， $ j $ 为在文法 $ G′ $ 中某产生式 $ A→α $ 的序号。 (3) 若 $ GO(I_k,A)＝I_j $ ，则置 $ GOTO[k,A] $ 为 $ G_j $ ，其中 $ A $ 为非终结符。 (4) 若项目 $ S′→S· $ 属于 $ I_k $ ，则置 $ ACTION $ [k,#]为 $ acc $ ，表示接受。 II. 关键函数 1. CLOSURE(J) 函数 即求J中每一项的闭包。 也可以用递归。 12345678function CLOSURE(J): I = J 重复执行： for I 中每个项目，形如A-&gt;α.Bβ，执行： for 增广文法中每一个以B开始的产生式，B-&gt;γ，执行： if 以B开始的加点最左侧的产生式，B-&gt;.γ 不在 I 中，将其加入 I 中 直到 I 不再增大 返回 I 2. GO(I,X) 函数 参数： $ I $ 为项目集闭包。 $ \lbrace X \rbrace $ 为 $ I $ 中点后字符的集合，因此 $ X $ 就是其中一项。 比如：$ I_0= \lbrace S\rightarrow .E, E\rightarrow .E+T, E\rightarrow .T, T\rightarrow .T*F, T\rightarrow .F, F\rightarrow .(E), F\rightarrow.g \rbrace $ ，则 $ \lbrace X \rbrace = \lbrace E, T, F, (, g \rbrace $，需要把 $ X $ 中每一项都传入 $ GO $ 函数进行计算。 12345function GO(I,X): J = Φ for I 中每一个项目，形如A-&gt;α.Xβ（点后面的字符为 X ），执行： J = J ∪ &#123;A-&gt;αX.β&#125;，即将点右移一位。 返回 CLOSURE(J)，即返回 J 的闭包 3. ★ 如何使用 $ CLOSURE(J) $ $ GO(I,X) $ 以下，大写字母为非终结符，小写字母或符号为终结符 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ ① 构造 $ I_0 $ 。即求增广文法的第一个产生式的闭包 $ CLOSURE( \lbrace S \rightarrow .E \rbrace ) $ 。 即 $ CLOSURE(J), J = {S \rightarrow .E} $ E是非终结符，所以找以E为开始的点在产生式右部的开始的产生式。$ E \rightarrow .T % $ , $ T $ 仍为非终结符，所以再像 $ E $ 一样找 $ T $，把它们都加入 $ J $。 ② 利用 $ GO(I_0, X) $ 构造 $ I_i $ 第①步求出了 $ I_0= \lbrace S\rightarrow .E, E\rightarrow .E+T, E\rightarrow .T, T\rightarrow .T*F, T\rightarrow .F, F\rightarrow .(E), F\rightarrow.g \rbrace $ (1) 首先找出 $ I_0 $ 中所有点后的字符， $ \lbrace X \rbrace = \lbrace E,T,F,(,g \rbrace $ (2) 每一个 $ \lbrace X \rbrace $ 中的字符都会作为 $ GO(I_0,X)中的参数X $ a. 求 $ GO(I_0, E) $ ,得到 $ I_1 $ 此时 $ X $ 为 $ E $ ， 即形如 $ A \rightarrow α.Xβ $ 的产生式为 $ \lbrace S\rightarrow .E,E\rightarrow .E+T \rbrace $ 因此 $ J = Φ ∪ \lbrace S\rightarrow E.,E\rightarrow E.+T \rbrace $ 然后求 $ CLOSURE(J) $ ,返回 $ I_1 $ b. 求 $ GO(I_0, T) $ ，得到 $ I_2 $ , 同上 … e. 求 $ GO(I_0, g) $ ，得到 $ I_5 $ , 同上 (3) 再找出 $ I_1 $ 中所有点后的字符， $ \lbrace X \rbrace = \lbrace + \rbrace $ f. 求 $ GO(I_1, +) $ ，得到 $ I_6 $ , 同上 … ③ 所有 $ I_x $ 的集合就是项目及规范族 $ C $ , $ C= \lbrace I_0, I_1, …, I_n \rbrace $ III. 实现 0. 数据结构 python 列表、集合等 1. 项目生成 步骤： ① 读取文法文件，存入列表 ② 遍历列表的所有元素，为其加点，从产生式的右边的第一个符号的左侧开始加点，点每次右移一位，直到移到最右侧，这些标有点的产生式就是文法的LR(0)项目，即 产生式：S-&gt;AB; 项目：(1) S-&gt;.AB (2) S-&gt;A.B (3) S-&gt;AB. 读取文法后，将终结符、非终结符分别存入终结符列表、非终结符列表，便于之后的判断。 2. 读取规范句型 将标识符、符号、关键字等读出，转换为文法可以识别的终结符与非终结符组成的串，等待识别。 3. $ CLOSURE $, $ GO $函数生成 $ CLOSURE(J) $ 12345678910111213141516171819202122232425# 为了与列表CLOSURE区分，我使用了CLOSURE FUNCTION 的简写 CLOSUREFdef CLOSUREF(J): tempClosure = [] for i in J: nodePosition = i.index(&apos;@&apos;) if (nodePosition == (len(i) - 1)) or ((i[nodePosition + 1]) in TERMINATOR): # 点在最后一位 或 点后是终结符 tempClosure.append(i) elif((i[nodePosition + 1]) in NONTERMINATOR): # 点后为非终结符 tempClosure.append(i) searchClosure(i[nodePosition+1], tempClosure) # 传入S-&gt;@B 中的 B，即找以 B 为开始的产生式 if tempClosure in CLOSURE: # 如果当前生成的CLOSURE已经生成过了，则直接返回之前生成的相同的CLOSURE return CLOSURE[CLOSURE.index(tempClosure)] CLOSURE.append(tempClosure) return tempClosuredef searchClosure(c, tempClosure): for i in grammarWithNode: # 遍历所有项目 if i[0] != c: continue if i[1] == &apos;@&apos;: # 点在产生式右部的开始 tempClosure.append(i) if c != i[2] and i[2] in NONTERMINATOR : # 点后的仍然是非终结符，如 E searchClosure(i[2], tempClosure) # 递归找以 E 为产生式开始的，且点在产生式右部的开始 $ GO(I,X) $ 12345678910111213def GO(I,X): J = [] for i in I: nodeIndex = i.index(&apos;@&apos;) if nodeIndex == len(i) - 1: continue if i[nodeIndex + 1] != X: continue moveRightStr = nodeRightMove(i) # 将点右移一位 J.append(moveRightStr) return CLOSUREF(J) 4. 求FIRST、FOLLOW集 FIRST: 寻找最左终结符 递归 如：求 $ S \rightarrow Eb $ 求S的FIRST集，E为终结符。 $ S \rightarrow E, E \rightarrow a $ 相当于 $ S \rightarrow a $ , 因此E的最左终结符一定是S的 $ E \rightarrow a , E \rightarrow T $ 同理，$ T $的终结符集一定是 $ E $的子集，依次向下递归即可。 FOLLOW: 寻找每个非终结符右侧的终结符，（不考虑空串的情况时） 有三种情况: ① $ A \rightarrow aBb $ , $ B $ 为非终结符， $ b $ 为终结符， $ FOLLOW(B) = FOLLOW(B) ∪ \lbrace b \rbrace $ ② $ A \rightarrow aB $ , $ B $ 为非终结符， $ E \rightarrow Af $ 即 $ E \rightarrow aBf $ ， 因此 $ A $ 的 $ FOLLOW $ 集就是B的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FOLLOW(A) $ ③ $ A \rightarrow aBE $ , $ B $ 为非终结符， $ E $ 为非终结符， $ E \rightarrow a $ 即 $ A \rightarrow aBa $ ，因此 $ E $ 的 $ FIRST $ 集就是 $ B $ 的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FIRST(E) $ 重复这个操作，直到所有 $ FOLLOW $ 集不再增大为止 5. 生成SLR分析表 ① 首先构造 $ I_0 $ , $ I_0 = CLOSURE( \lbrace S \rightarrow E \rbrace ) $，然后根据 &quot;3.&quot;的描述，求出 $ C = \lbrace I_0, I_1, …, I_n \rbrace $ ② $ I_0 $ 为初始状态。构造 $ action $ 表与 $ goto $ 表，$ action $ 表列标所有终结符和’#’, $ goto $表列标为所有终结符，行标均为所有项目及规范族的下标。 ③ 令初始状态 $ k = 0 $, k递增进行如下循环： (1) 如果 $ A \rightarrow α.aβ $ 在 $ I_k $ 中，并且 $ a $为终结符，那么求一下 $ GO(I_k, a) $ 的值是 $ C $中的哪一项，如果求出是 $ I_k $ ， 则 $ action[k,a] = Sj $ ，即在行标为 $ k $, 列标为 $ a $ 的位置上写入 $ Sj $。 (2) 如果 $ A \rightarrow α.Bβ $ 在 $ I_k $ 中，并且 $ B $为非终结符，那么那么求一下 $ GO(I_k, B) $ 的值是 $ C $中的哪一项，如果求出是 $ I_k $ , 则 $ goto[k,B] = Sj $，即在行标为 $ k $, 列标为 $ B $ 的位置上写入 $ j $。 (3) 如果 $ A \rightarrow α. $ , 并且 $ A \rightarrow α $ 在（不加点）文法 $ G $ 中是第 $ j $ 个产生式，那么对于每个终结符（包括#）$ t $ ，如果 $ t ∈ FOLLOW(A) $ ，（A为产生式左部）， 则 $ action[k,t] = rj $ ，即在行标为 $ k $ , 列标为满足要求的 $ t $ 的位置上写入 $ rj $ 。 (4) 如果当前项目为增广文法新加入的项目的中介状态 $ S \rightarrow E. ∈ I_k $ ， 则 $ action $ [k,#] $ = acc $ 。 遍历完 $ C $ 中所有 $ I $ 以及 $ I $ 中所有项目后，$ SLR $ 分析表就生成了。 12345678910111213141516171819202122def generateSLR(): global action, goto action = [[&apos; &apos; for col in range(len(TERMINATOR))] for row in range(len(CLOSURE))] goto = [[&apos; &apos; for col in range(len(NONTERMINATOR))] for row in range(len(CLOSURE))] for k in range(0, len(CLOSURE)): for a in CLOSURE[k]: # Closure内各表达式 nodeIndex = a.index(&apos;@&apos;) if nodeIndex == len(a) - 1: grammarIndex = grammarOriginalLists.index(a[0:len(a)-1]) for ter in TERMINATOR: if a[0] == grammarOriginalLists[0][0]: action[k][TERMINATOR.index(&apos;#&apos;)] = &quot;a0&quot; elif ter in FOLLOW[NONTERMINATOR.index(a[0])]: action[k][TERMINATOR.index(ter)] = &quot;r&quot; + str(grammarIndex) elif a[nodeIndex+1] in TERMINATOR: resultClosure = GO(CLOSURE[k], a[nodeIndex+1]) aIndex = CLOSURE.index(resultClosure) action[k][TERMINATOR.index(a[nodeIndex+1])] = &quot;S&quot; + str(aIndex) elif a[nodeIndex+1] in NONTERMINATOR: resultClosure = GO(CLOSURE[k], a[nodeIndex+1]) aIndex = CLOSURE.index(resultClosure) goto[k][NONTERMINATOR.index(a[nodeIndex+1])] = &quot;G&quot; + str(aIndex) 6. 进行语法分析 利用Python的数据结构列表模拟栈的操作，状态栈、符号栈分别存放当前状态、当前的符号，输入流不断进行输入，状态与当前输入利用SLR表进行转换，得到新的状态与符号。 三、 源码 https://git.dev.tencent.com/liysuzy/Compilers.git 如有问题请与我联系，1121899707@msn.cn]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Python</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLR语法分析器 C++实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F28%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%20C%2B%2B%2F</url>
    <content type="text"><![CDATA[在文章语法分析器python实现中描述了课本上的算法（利用CLOSURE、GO函数进行SLR分析表的建立）。 一、语法分析器做什么 语法分析是根据某种给定的形式文法对由单词序列（如英语单词序列）构成的输入文本进行分析并确定其语法结构的一种过程。 一个语法分析器从词法分析器获得一个词素序列，并验证这个序列是否可以由源语言的文法生成。语法分析器会构造一棵语法分析树，并把它传递给编译器的其他部分进一步处理，在构建语法分析树的过程中，就验证了这个词素序列是否符合源语言的文法。 二、自底向上的语法分析器的实现 I. 我的推导方式 步骤： 分析输入流，需要使用SLR分析表，[SLR(1),1省略] 得到SLR分析表，需要用DFA生成 得到DFA，需要用NFA生成，NFA-&gt;DFA需要用子集构造法，也就是需要得到Closure 得到NFA，需要得到文法中所有项目 得到项目，需要给文法加点 至此就推导到最开始的文法了 这种做法会有疏漏，但可以应对大部分的文法。 II. 实现 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ 0. 数据结构 文法：string 数组 项目集：vector&lt;itemStruct&gt; itemStruct为结构体 Closure：vector&lt;closureStruct&gt; item 等 1. 项目生成 步骤： ① 读取文法文件，将所有文法存入一种数据结构，我选择了string数组 ② 遍历string数组的所有元素，为其加点，从产生式的右边的第一个符号的左侧开始加点，点每次右移一位，直到移到最右侧，这些标有点的产生式就是文法的LR(0)项目，即 产生式：S-&gt;AB; 项目：(1) S-&gt;.AB (2) S-&gt;A.B (3) S-&gt;AB. 读取文法后，将终结符、非终结符分别存入数组，便于之后的判断。 2. 读取规范句型 将标识符、符号、关键字等读出，转换为文法可以识别的终结符与非终结符组成的串，等待识别。 3. NFA 生成 步骤： ① 遍历每一个项目 S ② 找当前加点位置的下一个字符 C a. 如果 C 是终结符，说明没有空边的情况 操作：需要将 S 中的点右移一位得到 S'，再遍历整个项目集寻找与之匹配的项目 A，A 就是 S 的后继，加入NFA图，值为该终结符 例如：S-&gt;.aE ====== a ======&gt; S-&gt;a.E b. 如果 C 是非终结符，此时存在空边。譬如，S-&gt;@E, E-&gt;@aB，S 等待 E 的输入，其实就是等待 a 的输入。也就是 S 间接推导到 aB。 操作： i. 将 S 加点右移一位得到 S'，若点在项目的最右位置，说明此时需要接收点之前的非终结符，遍历整个项目找到与 S' 匹配的项目下标，加入NFA图，值为该非终结符。 例如：S-&gt;@E ====== E ======&gt; S-&gt;E@ , 匹配S-&gt;E@ ii. 将 S 加点右移一位得到 S'，若点不在项目的最右位置，需要遍历整个项目集，寻找 以 S 加点右侧第一个非终结符为开始 的项目集合 {E} ，并且 E 的加点一定是在产生式右部的最左侧, 将它们加入NFA图，值为空边（用~表示，与空字符进行区分） 例如：S-&gt;@EB ====== ~ ======&gt; E-&gt;@aA, E-&gt;@B 4. $ C $ 生成 $ C $ 代表项目集规范族。 $ C = \lbrace I_0, I_1, I_2, … , I_n \rbrace $ 步骤： ① 读取NFA，每一个点坐标为(m,n)，m , n 代表两个项目，遍历每行构造Closure。 ② 如果 n 对应项目 已经被加入closure, 则不再以 n 作为源进行查找，即查找到第 n行，直接跳过。 ③ 递归 a. 如果NFA途中显示 (m,n) 值为~, 如果该项目还不在 m 构造的Closure中，则递归找该项目的空边，将其也加入Closure中，直到找到一个不含空边的项目为止。 b. 如果NFA途中显示 (m,n) 值不为~，也不为空, 如果该项目还不在 m 构造的Closure中，将其加入。 c. 如果遍历完一行发现为空，说明该状态可能为点在最右侧的状态，即需要归约的状态，需要构造一个Closure只包含该项目。 问题： 使用这种方法构造的Closure并不是真正意义的Closure，可能会出现有多余的Closure的情况， 出现这种情况需要将多余的Closure合并。 5. DFA 生成 数据结构： 1234567891011121314// 项目结构体typedef struct itemStruct&#123; int itemId; // 节点编号 char content[MAX_GRAMMER]; // 节点内容 bool isAdd; //是否添加到closure中 vector&lt;int&gt; closureIds; // 该item属于哪几个Closure&#125;itemStruct;typedef struct closureStruct&#123; int closureId; // 节点编号 vector&lt;int&gt; itemIds;// Closure 下的项目id&#125;closureStruct; 在上一步，我们求出了所有的项目集规范族（其实此时并不是完全规范的，下面会讲为什么），将C中的各项统称为Closure（闭包） 对每一个Closure中的vector&lt;int&gt; itemIds进行遍历，寻找该Closure可以指向谁。如果把每个Closure看作节点，那么这一步就是寻找两个节点的边以及权值。 譬如，当前要找Closure I0 可以与哪个Closure有有向边，因此我们需要遍历当前Closure下的所有item，即读取NFA图，如果该item所在的行有非空的值，说明该item一定可以通过这个非空的值指向下一个item，那么我们只需要知道指向的item在哪一个Closure中即可。（非常拗口，在后面我会举一个例子。） 当我们遍历完所有的Closure后，DFA图就生成了，DFA图中是不存在空边的！ 6. DFA 图的合并及真正的项目及规范族 $ C $ 生成 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ DFA 图（矩阵形式）如图所示 DFA 图的一部分（有向图形式）如图所示 可以看到，在DFA矩阵中，有第一行有两个E，实际上有向图中只有一个E，因为 $ S\rightarrow E., E\rightarrow E.+T $ 本身应该属于一个Closure中。因此需要合并这两个。 算法： ① 遍历整个DFA图，查找哪一行有重复的输入，将其合并。 ② 对于每个合并，要找其对应的两列是否也出现与其相同的情况。（如下图所示） 千万注意下图的情况！如果出现两次合并，Closure仍然是有重复的！因此当我们找到第一行的两个T时，要去找是否第五列、第六列也同时出现T，如果出现，在DFA图中直接将其删掉即可，这样就不会在第10行扫描的时候扫描到两个T。 7. 新的 DFA 生成 将原先的DFA清空。 我们通过DFA 图的合并，得到了真正的项目及规范族C，因此利用这个新的C可以生成完全正确的DFA图，该图就是生成SLR分析表的基础。 8. 求 FIRST、FOLLOW 集 FIRST: 寻找最左终结符 递归 如：求 $ S \rightarrow Eb $ 求S的FIRST集，E为终结符。 $ S \rightarrow E, E \rightarrow a $ 相当于 $ S \rightarrow a $ , 因此E的最左终结符一定是S的 $ E \rightarrow a , E \rightarrow T $ 同理，$ T $的终结符集一定是 $ E $的子集，依次向下递归即可。 FOLLOW: 寻找每个非终结符右侧的终结符，（不考虑空串的情况时） 有三种情况: ① $ A \rightarrow aBb $ , $ B $ 为非终结符， $ b $ 为终结符， $ FOLLOW(B) = FOLLOW(B) ∪ \lbrace b \rbrace $ ② $ A \rightarrow aB $ , $ B $ 为非终结符， $ E \rightarrow Af $ 即 $ E \rightarrow aBf $ ， 因此 $ A $ 的 $ FOLLOW $ 集就是B的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FOLLOW(A) $ ③ $ A \rightarrow aBE $ , $ B $ 为非终结符， $ E $ 为非终结符， $ E \rightarrow a $ 即 $ A \rightarrow aBa $ ，因此 $ E $ 的 $ FIRST $ 集就是 $ B $ 的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FIRST(E) $ 重复这个操作，直到所有 $ FOLLOW $ 集不再增大为止 9. 生成 SLR 分析表 ① 读取DFA图的每个坐标。 ② 判断当前的Closure是否有归约状态（含点在最右侧的产生式），如果有，则需要在该行终结符列下加入rj，j为归约到的文法中的第几项。（需要判断终结符是否在FOLLOW（X）集中，X为归约式的最左部） ③ 如果该坐标的值是非终结符，执行GOTO函数 ④ 如果该坐标的值是终结符，执行ACTION函数 ⑤ 如果出现了既不是终结符也不是非终结符的字符（比如空边），说明DFA图存在错误！SLR表无法生成！ ⑥ 最后，需要找出增广文法加入的产生式的终结状态（即点在最右侧），设其属于item的下标为index，&quot;#&quot;属于的下标为sharpIndex，则ACTION[index][sharpIndex] = “acc” ACTION 函数 ACTION(int closurId, char inTChar) ACTION函数的参数： 第一个：当前坐标的行标，也就是当前坐标所属Closure的下标。 第二个：坐标的值（终结符） ACTION函数的作用： 查找出 当前Closure输入该终结符可以指向的Closure的下标destIndex 在action表中加入一项。 位置：行标为closureId, 列标为当前终结符所属下标，加入的值是&quot;S&quot; + destIndex。 如上图所示，我们需要在action[0, (] 处添加S3，在action[1,g] 处添加S11. GOTO 函数 GOTO(int closurId, char inNTChar) ACTION函数的参数： 第一个：当前坐标的行标，也就是当前坐标所属Closure的下标。 第二个：坐标的值（非终结符） GOTO函数的作用： 查找出 当前Closure输入该非终结符可以指向的Closure的下标destIndex 在action表中加入一项。 位置：行标为closureId, 列标为当前终结符所属下标，加入的值为destIndex。 同上，不再举例。归约状态也如此。 通过这两个函数，SLR分析表就可以生成了。 10. 进行语法分析 利用C++栈模拟栈的操作，状态栈、符号栈分别存放当前状态、当前的符号，输入流不断进行输入，状态与当前输入利用SLR表进行转换，得到新的状态与符号。 三、 源码 https://git.dev.tencent.com/liysuzy/Compilers.git 如有问题请与我联系，1121899707@msn.cn]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装好虚拟机需要做~]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F24%2F%E8%A3%85%E5%A5%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Virtual Box 一、 增强功能 1. 增强功能的作用 实现客户机和主机间的鼠标平滑移动 安装虚拟显卡驱动，实现2D和3D视频图形加速，自动调整客户机分辨率 与主机共享剪贴板的内容，也就是说直接可以在主机、客户机之间复制、粘贴（不支持文件） 与主机实现文件共享（共享文件夹） 等等… 2. 安装增强功能 ① 进入系统 ② 点击菜单“设备”，点击下拉菜单“安装增强功能”。 ③ 弹出对话框，点击运行，会弹出输入密码对话框，输入即可。 ④ 安装程序自动安装，直到出现“Press Return to close this window…”，按回车结束，重启系统即可。 ⑤ 除此之外，需要开启共享剪切板才可以在主机和虚拟机之间复制剪贴板内容。 装完增强功能后，ubuntu关机时千万不要强制关机，要按正常步骤关机，否则增强功能可能会消失 3. 共享文件夹 注意：共享文件夹的前提是安装增强功能！ ① 设定共享文件夹。点击菜单“设备”，点击下拉菜单“共享文件夹”，点击右侧菜单“共享文件夹”。 ② 点击右侧加号，选择一个文件夹share，选择后点击自动挂载，固定分配。 ③ 打开命令行，需要输入以下命令 进入/mnt： cd /mnt 创建gongxiang目录： sudo mkdir gongxiang 将“share”目录与“gongxiang”目录进行关联： sudo mount -t vboxsf share /mnt/gongxiang 参数:&quot;share&quot;位置时你windows下的文件夹， &quot;/mnt/gongxiang&quot;位置时你linux下刚创建的哪个文件夹的绝对路径。 ④ 重启系统，现在我们可以在文件资源管理器中看到该文件夹，但是打开会报错 这时候我们需要获取权限，把本机用户加入到vboxsf之中 sudo adduser liysuzy vboxsf ⑤ 再次重启系统，以后就可以在共享文件夹下操作了！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Virtual Box</tag>
        <tag>Ubuntu</tag>
        <tag>增强功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器 C++实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F22%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、 词法分析做什么 词法分析是编译器的第一个步骤。 教材定义： 词法分析器读入组成源程序的字符流， 并且将它们组织成为有意义的词素(lexeme)的序列。 对于每个词素，词法分析器产生如下形式的词法单元(token)作为输出: &lt;token-name, attribute-value&gt; 词法分析器做的任务就是将源程序进行分解为以下五类单词 “标识符，关键字，常数，运算符，界符” 二、 词法分析器（简易）实现 整个程序流程： 对代码进行预处理，消除注释（单行、多行），目的是让词法分析时不进行过量的超前搜索与回退，以及减少判断注释时的内存消耗。将消除注释的代码存入另一个文件，为词法分析做准备。 读取不含注释的文件，进行单词的识别。每识别一个单词，需要向屏幕输出此法单元&lt;token-name, attribute-value&gt; 注解 将所有关键字、单目运算符、双目运算符、界符分别存放到数组中。 预处理————消除注释 C语言注释：// 单行注释 /* 多行注释 */ &quot;/&quot;出现时有几种情况：“除号”，“单行注释”，“多行注释”，“字符串内的字符常量” 因此需要对这几种情况进行判断。于是采用了编译原理中常用的————自动状态机 当然，这个程序中的状态机并不是严格按照状态机的定义来设计的，仅仅可以进行以上情况的判断。 状态机如下图： 使用状态机的好处: 避免了引号内有注释符号而被识别为注释的情况 可以查找注释不闭合与引号不闭合错误。因为如果读到文件终结时3状态或者5状态，都代表等待下一个/或者“的输入，也就是没有与上一个相匹配的字符。 内存开销小 预处理————文件读取 由于预处理无需进行超前搜索与回退，因此按字符读取是最节省空间与内存的。 词法分析————单词的识别 单词识别优先级： 字母&amp;数字====&gt;状态机外字符（运算符与部分分界符）====&gt;状态机内字符（需要进行状态转换） 但是这样识别会产生一个问题：引号内的字符会被视为标识符，甚至中文是乱码。 于是我考虑优先识别引号。 ① 如果识别到第一个引号，将阻塞后续字符的判断，因为代表这是在一个字符串内，不需要判断是否为标识符、关键字等，直到第二个引号进入，才停止阻塞。可以使用“模二求余”判断引号的单双数。 ② 遇到空格、Tab和回车跳过。 ③ 判断是否是字母或数字或下划线，如果是 是字母或下划线，表示是关键字或标识符，依次进行判断。 是数字开头，判断是否是合法数字。如果合法，是浮点数还是整数，依次进行判断。 ④ 判断是否是运算符 超前搜索一位，依次判断是否是双目运算符、单目运算符、界符。 至此，词法分析基本结束。 三、 词法分析器（简易）代码 https://coding.net/u/liysuzy/p/Compilers/git 包含源代码与测试用例，如果测试出现问题，可以联系1121899707@163.com，方便我完善程序。 （很不巧的是，做该项目这天github竟然宕机了！！！只好放在Coding.net了）]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>编译原理</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F14%2FGit%20%E5%9F%BA%E7%A1%80%20%2F</url>
    <content type="text"><![CDATA[一、Git简介 分布式版本控制系统 版本控制系统 本地： 他人无法得知工作 集中式：一旦服务器存在问题则丢失 分布式：服务器、本地均保存版本服务信息，若中央服务器存在问题，任意一台电脑均可以作为服务器。 二、 Git命令 1、 版本库 Remote Repository 远端版本库 Local Repository 本地 Staging 暂存，即将更新成为下一个版本，也有可能不会成为下一个版本 Working Directory 版本库的本地检出，即电脑可以看到的文件 2. git config 12git config --global user name &quot;user&quot;git config --global user email &quot;xxx@gmail.com&quot; 提交版本信息。 邮箱：共享工作成果，方便联系 用户名：提交用户 3. git clone git clone repo [directory] repo: url directory: 可选本地目录， 未指定为与远端相同 已有远端仓库clone到本地 clone 后, .git 目录： 存放相关版本信息 下面以Coding.net为远端版本库为例： 现在有一个已经创建好的版本库：我们来clone一下。 相应目录下Clone了这一个项目。 4. git init git init repo e.g. git init test 创建一个本地版本库 生成.git目录 直接创建本地git仓库，不需要有远端仓库 5. git status 查看工作区和暂存区的文件状态 那些被创建、修改…的文件 修改了README.md，添加了一个新文件test.txt，并加入内容。此时仅仅存放在工作区，尚未添加到暂存区中。 6. git add git add [-A] &lt;file&gt; e.g. git add -A e.g. git add file 添加文件从工作区到暂存区 A: All 暂存工作区成果等待提交 添加test.txt到暂存区，文件变成了带“+”的（因为我装了可视化界面Tortoise），此时已经加入暂存区。 下面使用另一个命令 7. git diff git diff - 查看工作区改动 git diff --cached - 查看暂存区改动 与 git status 的区别 gti diff 比 git status 更详细, 便于寻找改动，进行检查。 此时查看工作区改动，没有任何显示。因为此时工作区中没有任何文件。 查看暂存区改动，显示较为详细。注意：是–cached，两个“-”号 8. git commit git commit -m &quot;提交注释&quot; 让暂存区的文件真正变为下一个版本 注释为本次修改的内容梗概 9. git log 查看提交历史 git log 显示提交的用户名、邮箱、日期等，详细显示 git log --oneline 日志大纲，粗略显示 git log --oneline --graph 拓扑图展示 git log --oneline --reverse 逆向显示日志信息，时间正序来排列 10. git reset HEAD 游标： 当前活跃分支的游标 改变本地版本库 git reset --soft commit-id commit-id为错误commit之前的，即HEAD之前的任何一次commit 工作区、暂存区内容均不变，只改变本地版本库 回退到倒数第二次提交，将最后一次提交放入暂存区，即commit的反向操作 git reset --mixed commit-id 工作区不变、暂存区改变，是 git reset 的默认命令。 文件从暂存区删除，回到工作区，只是未被加入暂存区的一个状态。 git reset --hard commit-id 工作区、暂存区均改变 文件从工作区、暂存区删除，丢弃更改。 git reset --soft commit-id ：commit的逆向操作，由已经commit状态变成未commit状态。 git reset --mixed commit-id ：变成未添加状态，即删除了在暂存区中的文件，但是工作区的文件没有更改。 git reset --hard commit-id ：工作区文件也被删除。 11. git rm git rm &lt;file&gt; 从工作区和暂存区删除文件 git rm -f 强制删除 git rm --cached 从跟踪清单(暂存状态)中删除，文件仍然在目录中，在工作区中是一个未被跟踪的状态。 三、 Git分支 1. git branch git 分支 git branch &lt;branch-name&gt; 创建新分支 git branch 列出所有分支 git checkout &lt;branch-name&gt; 切换分支 git checkout -b &lt;branch-name&gt; 创建并切换分支 命名规则：略 git clone 工作区 本地版本库 上游版本库 git checkout git fetch https://learngitbranching.js.org/ 图形化工具 12345678910111213141516git branch featuregit branch- *master- featuregit checkout feature- git 分支切换git commit- feature 版本更新，master不变git checkout mastergit checkout -b bugfix- 创建bugfix 分支git commit- bugfix 工作内容更新，master不变 2. git merge 合并分支 分支上的内容需要手动合并到master分支上。 合并变为一次提交 为默认合并方式 12345git checkout master 切换到主分支git merge feature 合并feature到master（master更新，加入feature的内容，feature不变）git merge bugfix 合并bugfix到master（master更新，加入bugfix的内容，bugfix不变）git checkout feature 切换到feature git merge master 合并主分支 （将master合并到feature，feature当前在master路径之上，feature与master只差bugfix部分代码，feature会直接移动到master。该操作的原因：使新功能(feature)获得bugfix代码，使feature与master一致，以便于今后基于此进行开发，而不是在没有获得bugfix的feature之上开发。 3. git rebase 合并分支 将当前分支合并到xx分支上 合并仍为多次提交 rebase 合并后仍然可以看到修改的过程 主分支会保留所有分支修改历史 12345678git checkout feature 切换到feature分支git rebase master 将feature分支内容合并到master分支 （feature分支：C2 C3，master分支：C6，相当于将C2 C3直接依次放置在C6之下。）git checkout master git rebase feature 将主分支合并到feature上git checkout bugfixgit rebase mastergit checkout mastergit rebase bugfix 4. 冲突 merge conflict 分支的合并会出现修改冲突 出现冲突需要手动解决 同一文件同一位置的不同修改会出现冲突 冲突标识 出现冲突后，分支会处于merging的状态，直到解决冲突并且提交。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEADcontent1===============content2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;some-branch 解决方法：首先确定冲突内容，然后将content1 content2删掉，用合并后content填充，git add xxx. 5. delete branch 新分支的提交已经合并 针对无用的分支可以进行删除 git branch -d &lt;branch-name&gt; git 不是通过复制文件来管理版本库的，即使不删除文件也不会对磁盘空间造成很大影响。 四、Git远端操作 1. git fetch 拉取 从远端仓库获取数据，下载本地版本库缺少的提交，储存到本地版本库的远程分支 更新远程分支指针(如：origin/master，本地版本库的分支是与远端版本库的分支相对应的，master——origin/master, bugfix——origin/bugfix) origin/master ≠ master git fetch 不会改变本地仓库状态，不会改变master等分支 git fetch 不会改变工作区和暂存区的内容 需要将master与origin/master进行合并，才可以更新本地版本库的内容。 2. git pull 拉取 + 合并 ① 从远端仓库获取最新数据 ② 更新远程分支指针（如origin/master，origin/bugfix等） ③ 合并本地远端分支到本地分支（origin/master 与 master 合并， origin/bugfix 与 bugfix 合并） 可能出现合并冲突 3. git push 推送 ① 推送本地版本库内容到远端仓库 ② 更新本地仓库远程分支 ③ 更新远端仓库分支 git的数据共享是通过本地仓库的远程分支实现的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴阳师式神语音查询——SSM]]></title>
    <url>%2Fliysuzy%2F2018%2F09%2F11%2F2018-09-11-%E9%98%B4%E9%98%B3%E5%B8%88%E5%BC%8F%E7%A5%9E%E8%AF%AD%E9%9F%B3%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94SSM%2F</url>
    <content type="text"><![CDATA[一、需求 我非常喜欢阴阳师这款游戏，因为它精美的画面、建模、音乐，因为有许多重磅声优的加入，因为它玩法独特…… 然而由于式神说的都是日语，大多数时候我们并听不懂他们说的什么。NGA阴阳师论坛有每个式神的语音翻译，但是找起来太麻烦，因此我萌生了一个想法，写一个查询网站来显示每个式神的台词以及翻译，这样不久方便多了吗！ 去大连实训对SSM框架有了一定的了解，因此我仍然使用SSM框架。 二、数据库设计 阴阳师台词可以分为几类：点击、出场、受击、死亡、技能1、技能2、技能3几类。而每个类别下又可能有多条语音。我先列出了必需的字段： 式神名称 式神稀有度 声优 语音类型 日语语音 中文语音 面灵气 SSR 花泽香菜 点击1 XXXX XXXX 为了使数据库满足第三范式，我又对其进行了拆分与细化。 式神表 字段：式神ID、式神名称中文、式神名称英文、式神稀有度【外键】、式神CV【外键】 稀有度表 字段：稀有度ID、稀有度 CV表 字段：CV ID、CV姓名、CV国籍 语音表 字段：语音ID、式神ID【外键】、日文语音、中文语音、罗马语音、语音类型【外键】、语音音频地址 语音类型表 字段：语音类型ID、语音类型、觉醒前后 三、网页设计 原本想使用`bootstrap`做这个网站，但是`bootstrap`太过于传统商务。因此我使用了基于`bootstrap`的CSS框架`Flat-UI` （实际上只是用了这个CSS框架的响应式布局与按钮组件，2333333） 核心功能是显示语音台词，因此要醒目。于是我采取了如下图的一种设计。]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转木马]]></title>
    <url>%2Fliysuzy%2F2018%2F08%2F24%2F%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[追いかけて今日も歩き続ける 『僕にできること』 初 这是我的第一首原创歌曲《旋转木马》φ(゜▽゜*)♪ 故事 灵感来源： 同学放假回家，自己暂时呆在学校的失落。 灵感迸发： 欣赏了国家大剧院的《2011年无忧宫长笛音乐会》。 主旋： 采用和声小调式。 乐器选择： 主旋使用长笛，“笛”在中国古代多代表一种悲凉凄切的情感（西方长笛与中国“笛”不同，但音色仍然可以表达凄凉的情感）。长笛在交响乐队中常担任主要旋律，因此我选择长笛作为主旋乐器。[Native Instruments Kontakt Factory Library / Flute] 主歌的后部分与副歌使用长笛作为伴奏部分，但是演奏的仍然是主旋的变奏。 主歌的后部分与副歌使用弦乐作为旋律的演奏乐器，钢琴作为伴奏。弦乐使用的是以大提琴为主的音色，更浑厚、凄切，钢琴则演奏琶音与和声，二者相辅相成。 旋律设定： 开场即是主旋，而且一连演奏三遍，有人对我说是不是太多余，我认为是刚刚好吧，因此没有删掉一部分。三遍是循序渐进加入乐器，而且每一遍乐器的演奏风格是不同的，就使这种重复感降低。 副歌部分是主旋和弦的变奏，钢琴演奏的是主旋的变奏，而弦乐演奏的是主旋的底音，当然也有所变化。副歌结束后是一段钢琴的solo，渐强渐快。进入变奏。 变奏转换情感，激昂欢快，速度提升至170-180，其实这一段就是一段圆舞曲，可以想象… 故事描述：说了这些其实一听就可以感觉出来，其实上面的这些都是与故事相对应的…描绘几个场景 =￣ω￣= 王子与公主濒死 王子与公主展开回忆 王子幼时即被王后迫害 一位小女孩的到来让王子有了开心的生活 恶毒的王后要拆散王子与小女孩 王子与小女孩与王后斗智斗勇 悲剧 听起来似乎很幼稚，但是是一种理解。 本意是什么呢？(+_+)? 还是埋藏心底吧！ 分享：《SKY’s the limit》 楽しことばっかりの 人生なんかじゃないけど じゃあせめて今だけ 彩って夢見せて ----《SKY's the limit》 虽然生活并非都事事顺心令人愉悦，但是那也至少在此刻，染上希望实现梦想 。 Being alive, being vivid.]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站第一天！纪念一下]]></title>
    <url>%2Fliysuzy%2F2018%2F08%2F23%2Ffirst-day%2F</url>
    <content type="text"><![CDATA[不说啥了，开始工作！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
