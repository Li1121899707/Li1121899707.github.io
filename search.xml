<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SLR语法分析器 python实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F31%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%20%20python%2F</url>
    <content type="text"><![CDATA[一、语法分析器做什么 二、自底向上的语法分析器的实现 I. 推导方式 输入：文法 $ G=(V,T,P,S) $ 的拓广文法 $ G’ $ 输出： $ G’ $ 的 $ LR(0) $ 分析表。即 $ action $ 和 $ goto $ 表 步骤： ① 构造 $ I_0 $ 。 $ I_0 = CLOSURE( \lbrace S’ \rightarrow .S \rbrace ) $ ② 通过 $ GO(I_i, X) $ 函数求出 $ LR(0) $ 的项目集规范族 $ C= \lbrace I_0,I_1,…,I_n \rbrace $ ③ 遍历项目及规范族 $ C $ ， $ I_0 $ 对应初始状态 $ 0 $， $ I_i $ 对应状态 $ i $ (1) 若项目 $ A→α·aβ $ 属于 $ I_k $ 且转换函数 $ GO(I_k,a)= I_j $ ，当 $ a $ 为终结符时，则置 $ ACTION[k,a] $ 为 $ S_j $ 。 (2) 若项目 $ A→α· $ 属于 $ I_k $ ，则对任何终结符 $ a $ 和’#'置 $ ACTION[k,a] $ 和 $ ACTION $ [k,#]为 $ r_j $ ， $ j $ 为在文法 $ G′ $ 中某产生式 $ A→α $ 的序号。 (3) 若 $ GO(I_k,A)＝I_j $ ，则置 $ GOTO[k,A] $ 为 $ G_j $ ，其中 $ A $ 为非终结符。 (4) 若项目 $ S′→S· $ 属于 $ I_k $ ，则置 $ ACTION $ [k,#]为 $ acc $ ，表示接受。 II. 关键函数 1. CLOSURE(J) 函数 即求J中每一项的闭包。 也可以用递归。 12345678function CLOSURE(J): I = J 重复执行： for I 中每个项目，形如A-&gt;α.Bβ，执行： for 增广文法中每一个以B开始的产生式，B-&gt;γ，执行： if 以B开始的加点最左侧的产生式，B-&gt;.γ 不在 I 中，将其加入 I 中 直到 I 不再增大 返回 I 2. GO(I,X) 函数 参数： $ I $ 为项目集闭包。 $ \lbrace X \rbrace $ 为 $ I $ 中点后字符的集合，因此 $ X $ 就是其中一项。 比如：$ I_0= \lbrace S\rightarrow .E, E\rightarrow .E+T, E\rightarrow .T, T\rightarrow .T*F, T\rightarrow .F, F\rightarrow .(E), F\rightarrow.g \rbrace $ ，则 $ \lbrace X \rbrace = \lbrace E, T, F, (, g \rbrace $，需要把 $ X $ 中每一项都传入 $ GO $ 函数进行计算。 12345function GO(I,X): J = Φ for I 中每一个项目，形如A-&gt;α.Xβ（点后面的字符为 X ），执行： J = J ∪ &#123;A-&gt;αX.β&#125;，即将点右移一位。 返回 CLOSURE(J)，即返回 J 的闭包 3. 如何使用 $ CLOSURE(J) $ $ GO(I,X) $ 以下，大写字母为非终结符，小写字母或符号为终结符 文法： $ G = \lbrace S\rightarrow E, E\rightarrow E+T, E\rightarrow T, T\rightarrow T*F, T\rightarrow F, F\rightarrow (E), F\rightarrow g \rbrace ​ $ ① 构造 $ I_0 $ 。即求增广文法的第一个产生式的闭包 $ CLOSURE( \lbrace S \rightarrow .E \rbrace ) $ 。 即 $ CLOSURE(J), J = {S \rightarrow .E} $ E是非终结符，所以找以E为开始的点在产生式右部的开始的产生式。$ E \rightarrow .T % $ , $ T $ 仍为非终结符，所以再像 $ E $ 一样找 $ T $，把它们都加入 $ J $。 ② 利用 $ GO(I_0, X) $ 构造 $ I_i $ 第①步求出了 $ I_0= \lbrace S\rightarrow .E, E\rightarrow .E+T, E\rightarrow .T, T\rightarrow .T*F, T\rightarrow .F, F\rightarrow .(E), F\rightarrow.g \rbrace $ (1) 首先找出 $ I_0 $ 中所有点后的字符， $ \lbrace X \rbrace = \lbrace E,T,F,(,g \rbrace $ (2) 每一个 $ \lbrace X \rbrace $ 中的字符都会作为 $ GO(I_0,X)中的参数X $ a. 求 $ GO(I_0, E) $ ,得到 $ I_1 $ 此时 $ X $ 为 $ E $ ， 即形如 $ A \rightarrow α.Xβ $ 的产生式为 $ \lbrace S\rightarrow .E,E\rightarrow .E+T \rbrace $ 因此 $ J = Φ ∪ \lbrace S\rightarrow E.,E\rightarrow E.+T \rbrace $ 然后求 $ CLOSURE(J) $ ,返回 $ I_1 $ b. 求 $ GO(I_0, T) $ ，得到 $ I_2 $ , 同上 … e. 求 $ GO(I_0, g) $ ，得到 $ I_5 $ , 同上 (3) 再找出 $ I_1 $ 中所有点后的字符， $ \lbrace X \rbrace = \lbrace + \rbrace $ f. 求 $ GO(I_1, +) $ ，得到 $ I_6 $ , 同上 … ③ 所有 $ I_x $ 的集合就是项目及规范族 $ C $ , $ C= \lbrace I_0, I_1, …, I_n \rbrace $ III. 实现 0. 数据结构 python 列表、集合 1. 项目生成 步骤： ① 读取文法文件，存入列表 ② 遍历列表的所有元素，为其加点，从产生式的右边的第一个符号的左侧开始加点，点每次右移一位，直到移到最右侧，这些标有点的产生式就是文法的LR(0)项目，即 产生式：S-&gt;AB; 项目：(1) S-&gt;.AB (2) S-&gt;A.B (3) S-&gt;AB. 读取文法后，将终结符、非终结符分别存入终结符列表、非终结符列表，便于之后的判断。 2. 读取规范句型 将标识符、符号、关键字等读出，转换为文法可以识别的终结符与非终结符组成的串，等待识别。 3. $ CLOSURE $, $ GO $函数生成 $ CLOSURE(J) $ 12345678910111213141516171819202122232425# 为了与列表CLOSURE区分，我使用了CLOSURE FUNCTION 的简写 CLOSUREFdef CLOSUREF(J): tempClosure = [] for i in J: nodePosition = i.index(&apos;@&apos;) if (nodePosition == (len(i) - 1)) or ((i[nodePosition + 1]) in TERMINATOR): # 点在最后一位 或 点后是终结符 tempClosure.append(i) elif((i[nodePosition + 1]) in NONTERMINATOR): # 点后为非终结符 tempClosure.append(i) searchClosure(i[nodePosition+1], tempClosure) # 传入S-&gt;@B 中的 B，即找以 B 为开始的产生式 if tempClosure in CLOSURE: # 如果当前生成的CLOSURE已经生成过了，则直接返回之前生成的相同的CLOSURE return CLOSURE[CLOSURE.index(tempClosure)] CLOSURE.append(tempClosure) return tempClosuredef searchClosure(c, tempClosure): for i in grammarWithNode: # 遍历所有项目 if i[0] != c: continue if i[1] == &apos;@&apos;: # 点在产生式右部的开始 tempClosure.append(i) if c != i[2] and i[2] in NONTERMINATOR : # 点后的仍然是非终结符，如 E searchClosure(i[2], tempClosure) # 递归找以 E 为产生式开始的，且点在产生式右部的开始 $ GO(I,X) $ 12345678910111213def GO(I,X): J = [] for i in I: nodeIndex = i.index(&apos;@&apos;) if nodeIndex == len(i) - 1: continue if i[nodeIndex + 1] != X: continue moveRightStr = nodeRightMove(i) # 将点右移一位 J.append(moveRightStr) return CLOSUREF(J) 4. 求FIRST、FOLLOW集 FIRST: 寻找最左终结符 递归 如：求 $ S \rightarrow Eb $ 求S的FIRST集，E为终结符。 $ S \rightarrow E, E \rightarrow a $ 相当于 $ S \rightarrow a $ , 因此E的最左终结符一定是S的 $ E \rightarrow a , E \rightarrow T $ 同理，$ T $的终结符集一定是 $ E $的子集，依次向下递归即可。 FOLLOW: 寻找每个非终结符右侧的终结符，（不考虑空串的情况时） 有三种情况: ① $ A \rightarrow aBb $ , $ B $ 为非终结符， $ b $ 为终结符， $ FOLLOW(B) = FOLLOW(B) ∪ \lbrace b \rbrace $ ② $ A \rightarrow aB $ , $ B $ 为非终结符， $ E \rightarrow Af $ 即 $ E \rightarrow aBf $ ， 因此 $ A $ 的 $ FOLLOW $ 集就是B的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FOLLOW(A) $ ③ $ A \rightarrow aBE $ , $ B $ 为非终结符， $ E $ 为非终结符， $ E \rightarrow a $ 即 $ A \rightarrow aBa $ ，因此 $ E $ 的 $ FIRST $ 集就是 $ B $ 的 $ FOLLOW $ 集的一个子集，因此 $ FOLLOW(B) = FOLLOW(B) ∪ FIRST(E) $ 重复这个操作，直到所有 $ FOLLOW $ 集不再增大为止 5. 生成SLR分析表 ① 首先构造 $ I_0 $ , $ I_0 = CLOSURE( \lbrace S \rightarrow E \rbrace ) $，然后根据 &quot;3.&quot;的描述，求出 $ C = \lbrace I_0, I_1, …, I_n \rbrace $ ② $ I_0 $ 为初始状态。构造 $ action $ 表与 $ goto $ 表，$ action $ 表列标所有终结符和’#’, $ goto $表列标为所有终结符，行标均为所有项目及规范族的下标。 ③ 令初始状态 $ k = 0 $, k递增进行如下循环： (1) 如果 $ A \rightarrow α.aβ $ 在 $ I_k $ 中，并且 $ a $为终结符，那么求一下 $ GO(I_k, a) $ 的值是 $ C $中的哪一项，如果求出是 $ I_k $, 则 $ action[k,a] = Sj ，即在行标为 k $, 列标为 $ a $的位置上写入 $ Sj $。 (2) 如果 $ A \rightarrow α.Bβ $ 在 $ I_k $ 中，并且 $ B $为非终结符，那么那么求一下 $ GO(I_k, B) $ 的值是 $ C $中的哪一项，如果求出是 $ I_k $, 则 $ goto[k,B] = Sj ，即在行标为 k $, 列标为 $ B $的位置上写入 $ j $。 (3) 如果 $ A \rightarrow α. $ , 并且 $ A \rightarrow α $ 在（不加点）文法 $ G $ 中是第 $ j 个产生式，那么对于每个终结符（包括#） t $,如果 $ t ∈ FOLLOW(A) $，（A为产生式左部）， 则 $ action[k,t] = rj ，即在行标为 k $, 列标为满足要求的 $ t $的位置上写入 $ rj $。 (4) 如果当前项目为增广文法新加入的项目的中介状态 $ S \rightarrow E. ∈ I_k $， 则 $ action [k,#] = acc $。 遍历完$C 中所有 I $ 以及 $ I $ 中所有项目后，$ SLR $ 分析表就生成了。 12345678910111213141516171819202122def generateSLR(): global action, goto action = [[&apos; &apos; for col in range(len(TERMINATOR))] for row in range(len(CLOSURE))] goto = [[&apos; &apos; for col in range(len(NONTERMINATOR))] for row in range(len(CLOSURE))] for k in range(0, len(CLOSURE)): for a in CLOSURE[k]: # Closure内各表达式 nodeIndex = a.index(&apos;@&apos;) if nodeIndex == len(a) - 1: grammarIndex = grammarOriginalLists.index(a[0:len(a)-1]) for ter in TERMINATOR: if a[0] == grammarOriginalLists[0][0]: action[k][TERMINATOR.index(&apos;#&apos;)] = &quot;a0&quot; elif ter in FOLLOW[NONTERMINATOR.index(a[0])]: action[k][TERMINATOR.index(ter)] = &quot;r&quot; + str(grammarIndex) elif a[nodeIndex+1] in TERMINATOR: resultClosure = GO(CLOSURE[k], a[nodeIndex+1]) aIndex = CLOSURE.index(resultClosure) action[k][TERMINATOR.index(a[nodeIndex+1])] = &quot;S&quot; + str(aIndex) elif a[nodeIndex+1] in NONTERMINATOR: resultClosure = GO(CLOSURE[k], a[nodeIndex+1]) aIndex = CLOSURE.index(resultClosure) goto[k][NONTERMINATOR.index(a[nodeIndex+1])] = &quot;G&quot; + str(aIndex) 6. 进行语法分析]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLR语法分析器 C++实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F28%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%20c%2B%2B%2F</url>
    <content type="text"><![CDATA[一、语法分析器做什么 二、自底向上的语法分析器的实现 I. 我的推导方式 步骤： 分析输入流，需要使用SLR分析表，[SLR(1),1省略] 得到SLR分析表，需要用DFA生成 得到DFA，需要用NFA生成，NFA-&gt;DFA需要用子集构造法，也就是需要得到Closure 得到NFA，需要得到文法中所有项目 得到项目，需要给文法加点 至此就推导到最开始的文法了 这种做法会有疏漏，但可以应对大部分的文法。本身比较菜，课本上的算法着实很难懂。。。 II. 实现 0. 数据结构 文法：string 数组 项目集：vector&lt;itemStruct&gt; itemStruct为结构体 Closure：vector&lt;closureStruct&gt; item 等 1. 项目生成 步骤： ① 读取文法文件，将所有文法存入一种数据结构，我选择了string数组 ② 遍历string数组的所有元素，为其加点，从产生式的右边的第一个符号的左侧开始加点，点每次右移一位，直到移到最右侧，这些标有点的产生式就是文法的LR(0)项目，即 产生式：S-&gt;AB; 项目：(1) S-&gt;.AB (2) S-&gt;A.B (3) S-&gt;AB. 读取文法后，将终结符、非终结符分别存入数组，便于之后的判断。 2. 读取规范句型 将标识符、符号、关键字等读出，转换为文法可以识别的终结符与非终结符组成的串，等待识别。 3. NFA生成 步骤： ① 遍历每一个项目 S ② 找当前加点位置的下一个字符 C a. 如果 C 是终结符，说明没有空边的情况 操作：需要将 S 中的点右移一位得到 S'，再遍历整个项目集寻找与之匹配的项目 A，A 就是 S 的后继，加入NFA图，值为该终结符 例如：S-&gt;.aE ====== a ======&gt; S-&gt;a.E b. 如果 C 是非终结符，此时存在空边。譬如，S-&gt;@E, E-&gt;@aB，S 等待 E 的输入，其实就是等待 a 的输入。也就是 S 间接推导到 aB。 操作： i. 将 S 加点右移一位得到 S'，若点在项目的最右位置，说明此时需要接收点之前的非终结符，遍历整个项目找到与 S' 匹配的项目下标，加入NFA图，值为该非终结符。 例如：S-&gt;@E ====== E ======&gt; S-&gt;E@ , 匹配S-&gt;E@ ii. 将 S 加点右移一位得到 S'，若点不在项目的最右位置，需要遍历整个项目集，寻找 以 S 加点右侧第一个非终结符为开始 的项目集合 {E} ，并且 E 的加点一定是在产生式右部的最左侧, 将它们加入NFA图，值为空边（用~表示，与空字符进行区分） 例如：S-&gt;@EB ====== ~ ======&gt; E-&gt;@aA, E-&gt;@B 4. Closure 生成 步骤： ① 读取NFA，每一个点坐标为(m,n)，m , n 代表两个项目，遍历每行构造Closure。 ② 如果 n 对应项目 已经被加入closure, 则不再以 n 作为源进行查找，即查找到第 n行，直接跳过。 ③ 递归 a. 如果NFA途中显示 (m,n) 值为~, 如果该项目还不在 m 构造的Closure中，则递归找该项目的空边，将其也加入Closure中，直到找到一个不含空边的项目为止。 b. 如果NFA途中显示 (m,n) 值不为~，也不为空, 如果该项目还不在 m 构造的Closure中，将其加入。 c. 如果遍历完一行发现为空，说明该状态可能为点在最右侧的状态，即需要归约的状态，需要构造一个Closure只包含该项目。 问题： 使用这种方法构造的Closure并不是真正意义的Closure，可能会出现有多余的Closure的情况， 出现这种情况需要将多余的Closure合并。 未完待续]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>语法分析</tag>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装好虚拟机需要做~]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F24%2F%E8%A3%85%E5%A5%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Virtual Box 一、 增强功能 1. 增强功能的作用 实现客户机和主机间的鼠标平滑移动 安装虚拟显卡驱动，实现2D和3D视频图形加速，自动调整客户机分辨率 与主机共享剪贴板的内容，也就是说直接可以在主机、客户机之间复制、粘贴（不支持文件） 与主机实现文件共享（共享文件夹） 等等… 2. 安装增强功能 ① 进入系统 ② 点击菜单“设备”，点击下拉菜单“安装增强功能”。 ③ 弹出对话框，点击运行，会弹出输入密码对话框，输入即可。 ④ 安装程序自动安装，直到出现“Press Return to close this window…”，按回车结束，重启系统即可。 ⑤ 除此之外，需要开启共享剪切板才可以在主机和虚拟机之间复制剪贴板内容。 装完增强功能后，ubuntu关机时千万不要强制关机，要按正常步骤关机，否则增强功能可能会消失 3. 共享文件夹 注意：共享文件夹的前提是安装增强功能！ ① 设定共享文件夹。点击菜单“设备”，点击下拉菜单“共享文件夹”，点击右侧菜单“共享文件夹”。 ② 点击右侧加号，选择一个文件夹share，选择后点击自动挂载，固定分配。 ③ 打开命令行，需要输入以下命令 进入/mnt： cd /mnt 创建gongxiang目录： sudo mkdir gongxiang 将“share”目录与“gongxiang”目录进行关联： sudo mount -t vboxsf share /mnt/gongxiang 参数:&quot;share&quot;位置时你windows下的文件夹， &quot;/mnt/gongxiang&quot;位置时你linux下刚创建的哪个文件夹的绝对路径。 ④ 重启系统，现在我们可以在文件资源管理器中看到该文件夹，但是打开会报错 这时候我们需要获取权限，把本机用户加入到vboxsf之中 sudo adduser liysuzy vboxsf ⑤ 再次重启系统，以后就可以在共享文件夹下操作了！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Virtual Box</tag>
        <tag>Ubuntu</tag>
        <tag>增强功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法分析器 C++实现]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F22%2F%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、 词法分析做什么 词法分析是编译器的第一个步骤。 教材定义： 词法分析器读入组成源程序的字符流， 并且将它们组织成为有意义的词素(lexeme)的序列。 对于每个词素，词法分析器产生如下形式的词法单元(token)作为输出: &lt;token-name, attribute-value&gt; 词法分析器做的任务就是将源程序进行分解为以下五类单词 “标识符，关键字，常数，运算符，界符” 二、 词法分析器（简易）实现 整个程序流程： 对代码进行预处理，消除注释（单行、多行），目的是让词法分析时不进行过量的超前搜索与回退，以及减少判断注释时的内存消耗。将消除注释的代码存入另一个文件，为词法分析做准备。 读取不含注释的文件，进行单词的识别。每识别一个单词，需要向屏幕输出此法单元&lt;token-name, attribute-value&gt; 注解 将所有关键字、单目运算符、双目运算符、界符分别存放到数组中。 预处理————消除注释 C语言注释：// 单行注释 /* 多行注释 */ &quot;/&quot;出现时有几种情况：“除号”，“单行注释”，“多行注释”，“字符串内的字符常量” 因此需要对这几种情况进行判断。于是采用了编译原理中常用的————自动状态机 当然，这个程序中的状态机并不是严格按照状态机的定义来设计的，仅仅可以进行以上情况的判断。 状态机如下图： 使用状态机的好处: 避免了引号内有注释符号而被识别为注释的情况 可以查找注释不闭合与引号不闭合错误。因为如果读到文件终结时3状态或者5状态，都代表等待下一个/或者“的输入，也就是没有与上一个相匹配的字符。 内存开销小 预处理————文件读取 由于预处理无需进行超前搜索与回退，因此按字符读取是最节省空间与内存的。 词法分析————单词的识别 单词识别优先级： 字母&amp;数字====&gt;状态机外字符（运算符与部分分界符）====&gt;状态机内字符（需要进行状态转换） 但是这样识别会产生一个问题：引号内的字符会被视为标识符，甚至中文是乱码。 于是我考虑优先识别引号。 ① 如果识别到第一个引号，将阻塞后续字符的判断，因为代表这是在一个字符串内，不需要判断是否为标识符、关键字等，直到第二个引号进入，才停止阻塞。可以使用“模二求余”判断引号的单双数。 ② 遇到空格、Tab和回车跳过。 ③ 判断是否是字母或数字或下划线，如果是 是字母或下划线，表示是关键字或标识符，依次进行判断。 是数字开头，判断是否是合法数字。如果合法，是浮点数还是整数，依次进行判断。 ④ 判断是否是运算符 超前搜索一位，依次判断是否是双目运算符、单目运算符、界符。 至此，词法分析基本结束。 三、 词法分析器（简易）代码 https://coding.net/u/liysuzy/p/Compilers/git 包含源代码与测试用例，如果测试出现问题，可以联系1121899707@163.com，方便我完善程序。 （很不巧的是，做该项目这天github竟然宕机了！！！只好放在Coding.net了）]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础]]></title>
    <url>%2Fliysuzy%2F2018%2F10%2F14%2FGit%20%E5%9F%BA%E7%A1%80%20%2F</url>
    <content type="text"><![CDATA[一、Git简介 分布式版本控制系统 版本控制系统 本地： 他人无法得知工作 集中式：一旦服务器存在问题则丢失 分布式：服务器、本地均保存版本服务信息，若中央服务器存在问题，任意一台电脑均可以作为服务器。 二、 Git命令 1、 版本库 Remote Repository 远端版本库 Local Repository 本地 Staging 暂存，即将更新成为下一个版本，也有可能不会成为下一个版本 Working Directory 版本库的本地检出，即电脑可以看到的文件 2. git config 12git config --global user name &quot;user&quot;git config --global user email &quot;xxx@gmail.com&quot; 提交版本信息。 邮箱：共享工作成果，方便联系 用户名：提交用户 3. git clone git clone repo [directory] repo: url directory: 可选本地目录， 未指定为与远端相同 已有远端仓库clone到本地 clone 后, .git 目录： 存放相关版本信息 下面以Coding.net为远端版本库为例： 现在有一个已经创建好的版本库：我们来clone一下。 相应目录下Clone了这一个项目。 4. git init git init repo e.g. git init test 创建一个本地版本库 生成.git目录 直接创建本地git仓库，不需要有远端仓库 5. git status 查看工作区和暂存区的文件状态 那些被创建、修改…的文件 修改了README.md，添加了一个新文件test.txt，并加入内容。此时仅仅存放在工作区，尚未添加到暂存区中。 6. git add git add [-A] &lt;file&gt; e.g. git add -A e.g. git add file 添加文件从工作区到暂存区 A: All 暂存工作区成果等待提交 添加test.txt到暂存区，文件变成了带“+”的（因为我装了可视化界面Tortoise），此时已经加入暂存区。 下面使用另一个命令 7. git diff git diff - 查看工作区改动 git diff --cached - 查看暂存区改动 与 git status 的区别 gti diff 比 git status 更详细, 便于寻找改动，进行检查。 此时查看工作区改动，没有任何显示。因为此时工作区中没有任何文件。 查看暂存区改动，显示较为详细。注意：是–cached，两个“-”号 8. git commit git commit -m &quot;提交注释&quot; 让暂存区的文件真正变为下一个版本 注释为本次修改的内容梗概 9. git log 查看提交历史 git log 显示提交的用户名、邮箱、日期等，详细显示 git log --oneline 日志大纲，粗略显示 git log --oneline --graph 拓扑图展示 git log --oneline --reverse 逆向显示日志信息，时间正序来排列 10. git reset HEAD 游标： 当前活跃分支的游标 改变本地版本库 git reset --soft commit-id commit-id为错误commit之前的，即HEAD之前的任何一次commit 工作区、暂存区内容均不变，只改变本地版本库 回退到倒数第二次提交，将最后一次提交放入暂存区，即commit的反向操作 git reset --mixed commit-id 工作区不变、暂存区改变，是 git reset 的默认命令。 文件从暂存区删除，回到工作区，只是未被加入暂存区的一个状态。 git reset --hard commit-id 工作区、暂存区均改变 文件从工作区、暂存区删除，丢弃更改。 git reset --soft commit-id ：commit的逆向操作，由已经commit状态变成未commit状态。 git reset --mixed commit-id ：变成未添加状态，即删除了在暂存区中的文件，但是工作区的文件没有更改。 git reset --hard commit-id ：工作区文件也被删除。 11. git rm git rm &lt;file&gt; 从工作区和暂存区删除文件 git rm -f 强制删除 git rm --cached 从跟踪清单(暂存状态)中删除，文件仍然在目录中，在工作区中是一个未被跟踪的状态。 三、 Git分支 1. git branch git 分支 git branch &lt;branch-name&gt; 创建新分支 git branch 列出所有分支 git checkout &lt;branch-name&gt; 切换分支 git checkout -b &lt;branch-name&gt; 创建并切换分支 命名规则：略 git clone 工作区 本地版本库 上游版本库 git checkout git fetch https://learngitbranching.js.org/ 图形化工具 12345678910111213141516git branch featuregit branch- *master- featuregit checkout feature- git 分支切换git commit- feature 版本更新，master不变git checkout mastergit checkout -b bugfix- 创建bugfix 分支git commit- bugfix 工作内容更新，master不变 2. git merge 合并分支 分支上的内容需要手动合并到master分支上。 合并变为一次提交 为默认合并方式 12345git checkout master 切换到主分支git merge feature 合并feature到master（master更新，加入feature的内容，feature不变）git merge bugfix 合并bugfix到master（master更新，加入bugfix的内容，bugfix不变）git checkout feature 切换到feature git merge master 合并主分支 （将master合并到feature，feature当前在master路径之上，feature与master只差bugfix部分代码，feature会直接移动到master。该操作的原因：使新功能(feature)获得bugfix代码，使feature与master一致，以便于今后基于此进行开发，而不是在没有获得bugfix的feature之上开发。 3. git rebase 合并分支 将当前分支合并到xx分支上 合并仍为多次提交 rebase 合并后仍然可以看到修改的过程 主分支会保留所有分支修改历史 12345678git checkout feature 切换到feature分支git rebase master 将feature分支内容合并到master分支 （feature分支：C2 C3，master分支：C6，相当于将C2 C3直接依次放置在C6之下。）git checkout master git rebase feature 将主分支合并到feature上git checkout bugfixgit rebase mastergit checkout mastergit rebase bugfix 4. 冲突 merge conflict 分支的合并会出现修改冲突 出现冲突需要手动解决 同一文件同一位置的不同修改会出现冲突 冲突标识 出现冲突后，分支会处于merging的状态，直到解决冲突并且提交。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEADcontent1===============content2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;some-branch 解决方法：首先确定冲突内容，然后将content1 content2删掉，用合并后content填充，git add xxx. 5. delete branch 新分支的提交已经合并 针对无用的分支可以进行删除 git branch -d &lt;branch-name&gt; git 不是通过复制文件来管理版本库的，即使不删除文件也不会对磁盘空间造成很大影响。 四、Git远端操作 1. git fetch 拉取 从远端仓库获取数据，下载本地版本库缺少的提交，储存到本地版本库的远程分支 更新远程分支指针(如：origin/master，本地版本库的分支是与远端版本库的分支相对应的，master——origin/master, bugfix——origin/bugfix) origin/master ≠ master git fetch 不会改变本地仓库状态，不会改变master等分支 git fetch 不会改变工作区和暂存区的内容 需要将master与origin/master进行合并，才可以更新本地版本库的内容。 2. git pull 拉取 + 合并 ① 从远端仓库获取最新数据 ② 更新远程分支指针（如origin/master，origin/bugfix等） ③ 合并本地远端分支到本地分支（origin/master 与 master 合并， origin/bugfix 与 bugfix 合并） 可能出现合并冲突 3. git push 推送 ① 推送本地版本库内容到远端仓库 ② 更新本地仓库远程分支 ③ 更新远端仓库分支 git的数据共享是通过本地仓库的远程分支实现的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴阳师式神语音查询——SSM]]></title>
    <url>%2Fliysuzy%2F2018%2F09%2F11%2F2018-09-11-%E9%98%B4%E9%98%B3%E5%B8%88%E5%BC%8F%E7%A5%9E%E8%AF%AD%E9%9F%B3%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94SSM%2F</url>
    <content type="text"><![CDATA[一、需求 我非常喜欢阴阳师这款游戏，因为它精美的画面、建模、音乐，因为有许多重磅声优的加入，因为它玩法独特…… 然而由于式神说的都是日语，大多数时候我们并听不懂他们说的什么。NGA阴阳师论坛有每个式神的语音翻译，但是找起来太麻烦，因此我萌生了一个想法，写一个查询网站来显示每个式神的台词以及翻译，这样不久方便多了吗！ 去大连实训对SSM框架有了一定的了解，因此我仍然使用SSM框架。 二、数据库设计 阴阳师台词可以分为几类：点击、出场、受击、死亡、技能1、技能2、技能3几类。而每个类别下又可能有多条语音。我先列出了必需的字段： 式神名称 式神稀有度 声优 语音类型 日语语音 中文语音 面灵气 SSR 花泽香菜 点击1 XXXX XXXX 为了使数据库满足第三范式，我又对其进行了拆分与细化。 式神表 字段：式神ID、式神名称中文、式神名称英文、式神稀有度【外键】、式神CV【外键】 稀有度表 字段：稀有度ID、稀有度 CV表 字段：CV ID、CV姓名、CV国籍 语音表 字段：语音ID、式神ID【外键】、日文语音、中文语音、罗马语音、语音类型【外键】、语音音频地址 语音类型表 字段：语音类型ID、语音类型、觉醒前后 三、网页设计 原本想使用`bootstrap`做这个网站，但是`bootstrap`太过于传统商务。因此我使用了基于`bootstrap`的CSS框架`Flat-UI` （实际上只是用了这个CSS框架的响应式布局与按钮组件，2333333） 核心功能是显示语音台词，因此要醒目。于是我采取了如下图的一种设计。]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转木马]]></title>
    <url>%2Fliysuzy%2F2018%2F08%2F24%2F%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[追いかけて今日も歩き続ける 『僕にできること』 初 这是我的第一首原创歌曲《旋转木马》φ(゜▽゜*)♪ 故事 灵感来源： 同学放假回家，自己暂时呆在学校的失落。 灵感迸发： 欣赏了国家大剧院的《2011年无忧宫长笛音乐会》。 主旋： 采用和声小调式。 乐器选择： 主旋使用长笛，“笛”在中国古代多代表一种悲凉凄切的情感（西方长笛与中国“笛”不同，但音色仍然可以表达凄凉的情感）。长笛在交响乐队中常担任主要旋律，因此我选择长笛作为主旋乐器。[Native Instruments Kontakt Factory Library / Flute] 主歌的后部分与副歌使用长笛作为伴奏部分，但是演奏的仍然是主旋的变奏。 主歌的后部分与副歌使用弦乐作为旋律的演奏乐器，钢琴作为伴奏。弦乐使用的是以大提琴为主的音色，更浑厚、凄切，钢琴则演奏琶音与和声，二者相辅相成。 旋律设定： 开场即是主旋，而且一连演奏三遍，有人对我说是不是太多余，我认为是刚刚好吧，因此没有删掉一部分。三遍是循序渐进加入乐器，而且每一遍乐器的演奏风格是不同的，就使这种重复感降低。 副歌部分是主旋和弦的变奏，钢琴演奏的是主旋的变奏，而弦乐演奏的是主旋的底音，当然也有所变化。副歌结束后是一段钢琴的solo，渐强渐快。进入变奏。 变奏转换情感，激昂欢快，速度提升至170-180，其实这一段就是一段圆舞曲，可以想象… 故事描述：说了这些其实一听就可以感觉出来，其实上面的这些都是与故事相对应的…描绘几个场景 =￣ω￣= 王子与公主濒死 王子与公主展开回忆 王子幼时即被王后迫害 一位小女孩的到来让王子有了开心的生活 恶毒的王后要拆散王子与小女孩 王子与小女孩与王后斗智斗勇 悲剧 听起来似乎很幼稚，但是是一种理解。 本意是什么呢？(+_+)? 还是埋藏心底吧！ 分享：《SKY’s the limit》 楽しことばっかりの 人生なんかじゃないけど じゃあせめて今だけ 彩って夢見せて ----《SKY's the limit》 虽然生活并非都事事顺心令人愉悦，但是那也至少在此刻，染上希望实现梦想 。 Being alive, being vivid.]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站第一天！纪念一下]]></title>
    <url>%2Fliysuzy%2F2018%2F08%2F23%2Ffirst-day%2F</url>
    <content type="text"><![CDATA[不说啥了，开始工作！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
